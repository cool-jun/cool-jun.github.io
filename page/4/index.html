<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Like Sunday，Like Rain">
<meta property="og:type" content="website">
<meta property="og:title" content="cool-jun的博客">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="cool-jun的博客">
<meta property="og:description" content="Like Sunday，Like Rain">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="He Jun">
<meta property="article:tag" content="科研狗的生活">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>cool-jun的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">cool-jun的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">record my life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/09/shouqi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="He Jun">
      <meta itemprop="description" content="Like Sunday，Like Rain">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cool-jun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/09/shouqi/" class="post-title-link" itemprop="url">首汽面试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-09 19:49:26" itemprop="dateCreated datePublished" datetime="2022-03-09T19:49:26+08:00">2022-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-17 15:27:57" itemprop="dateModified" datetime="2022-04-17T15:27:57+08:00">2022-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/09/shouqi/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/09/shouqi/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2022年3月9号<br>由于本次面试是线下面试，一些问题记不太清，本次面试基本都是拿着简历问问题。</p>
<h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1 自我介绍"></a>1 自我介绍</h3><h3 id="2-介绍研究方向"><a href="#2-介绍研究方向" class="headerlink" title="2 介绍研究方向"></a>2 介绍研究方向</h3><h3 id="3-docker常用命令"><a href="#3-docker常用命令" class="headerlink" title="3 docker常用命令"></a>3 docker常用命令</h3><p><a target="_blank" rel="noopener" href="https://cool-jun.github.io/2022/04/16/docker/">docker</a></p>
<h3 id="4-redis数据类型"><a href="#4-redis数据类型" class="headerlink" title="4 redis数据类型"></a>4 redis数据类型</h3><p>string、list、hash、set、zset</p>
<h3 id="5-说说spring-ioc与aop"><a href="#5-说说spring-ioc与aop" class="headerlink" title="5 说说spring ioc与aop"></a>5 说说spring ioc与aop</h3><p><a target="_blank" rel="noopener" href="https://cool-jun.github.io/2021/12/05/12-05-Spring/">ioc</a><br><a target="_blank" rel="noopener" href="https://cool-jun.github.io/2021/12/10/12-10-Spring/">aop</a></p>
<h3 id="6-创建多线程的方式"><a href="#6-创建多线程的方式" class="headerlink" title="6 创建多线程的方式"></a>6 创建多线程的方式</h3><p>见蔚来一面</p>
<h3 id="7-说说线程池"><a href="#7-说说线程池" class="headerlink" title="7 说说线程池"></a>7 说说线程池</h3><p><a target="_blank" rel="noopener" href="https://cool-jun.github.io/2021/11/24/11-24-Java/">概念</a><br><a target="_blank" rel="noopener" href="https://cool-jun.github.io/2021/11/26/11-26-Java/">创建方式</a></p>
<h3 id="8-jvm详细说一下"><a href="#8-jvm详细说一下" class="headerlink" title="8 jvm详细说一下"></a>8 jvm详细说一下</h3><p><a target="_blank" rel="noopener" href="https://cool-jun.github.io/2021/11/27/11-27-Java/">jvm</a></p>
<h3 id="9-垃圾回收机制"><a href="#9-垃圾回收机制" class="headerlink" title="9 垃圾回收机制"></a>9 垃圾回收机制</h3><p><a target="_blank" rel="noopener" href="https://cool-jun.github.io/2021/12/04/12-04-Java/">gc</a></p>
<h3 id="10-垃圾收集器有哪些？说一下G1"><a href="#10-垃圾收集器有哪些？说一下G1" class="headerlink" title="10 垃圾收集器有哪些？说一下G1"></a>10 垃圾收集器有哪些？说一下G1</h3><p><a target="_blank" rel="noopener" href="https://cool-jun.github.io/2021/12/04/12-04-Java/">collector</a></p>
<h3 id="11-spring有哪些注解，说一下-Resource注解"><a href="#11-spring有哪些注解，说一下-Resource注解" class="headerlink" title="11 spring有哪些注解，说一下@Resource注解"></a>11 spring有哪些注解，说一下@Resource注解</h3><p>Spring中的注解主要分为两类：</p>
<ul>
<li><p>类级别的注解：如@Component、@Repository、@Controller、@Service以及JavaEE6的@ManagedBean和@Named注解，都是添加在类上面的类级别注解。</p>
</li>
<li><p>类内部的注解：如@Autowire、@Value、@Resource以及EJB和WebService相关的注解等，都是添加在类内部的字段或者方法上的类内部注解。</p>
</li>
</ul>
<p>具体的来说又有以下几种类型的注解方式</p>
<ol>
<li><p>声明bean的注解<br>@Component，通用的注解方式<br>@Service，在业务逻辑层使用（service层）<br>@Repository，在数据访问层使用（dao层）<br>@Controller，在表现层使用，控制器的声明</p>
</li>
<li><p>注入bean的注解<br>@Autowired：由Spring提供<br>@Inject：由JSR-330提供<br>@Resource：由JSR-250提供<br>都可以注解在set方法和属性上，推荐注解在属性上（一目了然，少写代码）。</p>
</li>
<li><p>java配置类相关注解<br>@Configuration，声明当前类为配置类，相当于xml形式的Spring配置（类上）<br>@Bean，注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）<br>@Configuration，声明当前类为配置类，其中内部组合了@Component注解，表明这个类是一个bean（类上）<br>@ComponentScan，用于对Component进行扫描，相当于xml中的（类上）<br>@WishlyConfiguration，为@Configuration与@ComponentScan的组合注解，可以替代这两个注解</p>
</li>
<li><p>切面（AOP）相关注解 Spring支持AspectJ的注解式切面编程。<br>@Aspect，声明一个切面（类上）<br>使用@After、@Before、@Around定义通知（advice），可直接将拦截规则（切点）作为参数。<br>@After，在方法执行之后执行（方法上） @Before 在方法执行之前执行（方法上） @Around 在方法执行之前与之后执行（方法上）<br>@PointCut，声明切点<br>在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）</p>
</li>
<li><p>@Bean的属性支持<br>@Scope，设置Spring容器如何新建Bean实例（方法上，得有@Bean）<br>其设置类型包括：<br>· Singleton （单例，一个Spring容器中只有一个bean实例，默认模式）,<br>· Protetype （每次调用新建一个bean）,<br>· Request （web项目中，给每个http request新建一个bean）,<br>· Session （web项目中，给每个http session新建一个bean）,<br>· GlobalSession（给每一个 global http session新建一个Bean实例）</p>
</li>
</ol>
<p>@Autowired与@Resource<br>@Autowired默认按类型查找，有查找的优先顺序。<br>按Type匹配（Match by Type）<br>按Qualifier匹配（Match by Qualifier）<br>按Name匹配（Match by Name）</p>
<p>如果要允许null值，可以设置它的required属性为false，如：@Autowired(required=false)。<br>若想要按名称装配，可以结合@Qualifier注解一起使用，如：@Autowired(required=false)<br>@Qualifier(“bean”)</p>
<p>@Resource默认按名字查找，但是也有查找的优先顺序。<br>按Name匹配（Match by Name）<br>按Type匹配（Match by Type）<br>按Qualifier匹配（Match by Qualifier）</p>
<p>@Resource注解和@Autowired一样，也可以标注在字段或属性的setter方法上。<br>Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。</p>
<p>@Resource装配顺序</p>
<ol>
<li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常</li>
<li>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常</li>
<li>如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常</li>
<li>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；</li>
</ol>
<h3 id="12-说一下git常用命令，rebase命令了解吗？"><a href="#12-说一下git常用命令，rebase命令了解吗？" class="headerlink" title="12 说一下git常用命令，rebase命令了解吗？"></a>12 说一下git常用命令，rebase命令了解吗？</h3><p><a target="_blank" rel="noopener" href="https://cool-jun.github.io/2022/01/08/01-08-git/">git</a></p>
<h3 id="13-说一下osi七层模型"><a href="#13-说一下osi七层模型" class="headerlink" title="13 说一下osi七层模型"></a>13 说一下osi七层模型</h3><img src="/2022/03/09/shouqi/osi.png" class="">

<h3 id="14-为什么tcp建立连接是三次握手，释放连接却是四次挥手？"><a href="#14-为什么tcp建立连接是三次握手，释放连接却是四次挥手？" class="headerlink" title="14 为什么tcp建立连接是三次握手，释放连接却是四次挥手？"></a>14 为什么tcp建立连接是三次握手，释放连接却是四次挥手？</h3><p><a target="_blank" rel="noopener" href="https://cool-jun.github.io/2021/12/11/12-11-Network/">三次握手</a><br><a target="_blank" rel="noopener" href="https://cool-jun.github.io/2021/12/13/12-13-Network/">四次挥手</a></p>
<h3 id="15-十亿条无序的数据，找出其中最大的10条。（top-k问题）"><a href="#15-十亿条无序的数据，找出其中最大的10条。（top-k问题）" class="headerlink" title="15 十亿条无序的数据，找出其中最大的10条。（top k问题）"></a>15 十亿条无序的数据，找出其中最大的10条。（top k问题）</h3><p>针对top K问题，通常比较好的方案是：分治+hash+小顶堆。</p>
<p>例如：1亿个数据中找出最大的前100个。<br>hash：如果这1亿个数里面有很多重复的数，先通过Hash，把这1亿个数去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的100个数。<br>分治：将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的100个，最后在剩下的10000个数据里面找出最大的100个。<br>小顶堆。</p>
<p><strong>PriorityQueue</strong></p>
<h3 id="16-算法题：单链表反转"><a href="#16-算法题：单链表反转" class="headerlink" title="16 算法题：单链表反转"></a>16 算法题：单链表反转</h3><p>头插法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    ListNode previous &#x3D; null;</span><br><span class="line">    ListNode current &#x3D; head;</span><br><span class="line">    while (current !&#x3D; null) &#123;</span><br><span class="line">        ListNode after &#x3D; current.next;</span><br><span class="line">        current.next &#x3D; previous;</span><br><span class="line">        previous &#x3D; current;</span><br><span class="line">        current &#x3D; after;</span><br><span class="line">    &#125;</span><br><span class="line">    return previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newHead &#x3D; reverseList(head.next);</span><br><span class="line">    head.next.next &#x3D; head;</span><br><span class="line">    head.next &#x3D; null;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-HR面"><a href="#17-HR面" class="headerlink" title="17 HR面"></a>17 HR面</h3><p>日常聊天半小时，面试通过。<br>3月15日婉拒offer。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/09/jingsuan-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="He Jun">
      <meta itemprop="description" content="Like Sunday，Like Rain">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cool-jun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/09/jingsuan-1/" class="post-title-link" itemprop="url">鲸算一面</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-09 09:16:24" itemprop="dateCreated datePublished" datetime="2022-03-09T09:16:24+08:00">2022-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-12 20:28:15" itemprop="dateModified" datetime="2022-09-12T20:28:15+08:00">2022-09-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/09/jingsuan-1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/09/jingsuan-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2022年3月8号，鲸算一面。</p>
<h3 id="1-介绍项目（简历上写的科研项目）"><a href="#1-介绍项目（简历上写的科研项目）" class="headerlink" title="1 介绍项目（简历上写的科研项目）"></a>1 介绍项目（简历上写的科研项目）</h3><h3 id="2-hashCode与equals方法的区别与联系"><a href="#2-hashCode与equals方法的区别与联系" class="headerlink" title="2 hashCode与equals方法的区别与联系"></a>2 hashCode与equals方法的区别与联系</h3><p>见蔚来一面</p>
<h3 id="3-泛型（T、K、V、E、？）"><a href="#3-泛型（T、K、V、E、？）" class="headerlink" title="3 泛型（T、K、V、E、？）"></a>3 泛型（T、K、V、E、？）</h3><p>泛型使类型（类和接口）在定义类、接口、方法时成为参数。<br><strong>类型参数命令约定</strong><br>E - Element(Java集合框架广泛使用)<br>T - Type<br>K - Key<br>V - Value<br>N - Number</p>
<p><strong>通配符</strong><br>？ - 表示未知类型<br>通配符可用于多种情况：作为参数、字段或局部变量的类型；有时作为返回类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上限通配符，&lt;? extends Foo&gt;，其中Foo是任何类型，匹配Foo和Foo的任何子类型。</span><br><span class="line">无界通配符类型使用通配符(?)指定，例如List&lt;?&gt;，称为未知类型的列表。</span><br><span class="line">需要注意的是List&lt;Object&gt;和List&lt;?&gt;并不相同。您可以将Object或Object的任何子类型插入到List&lt;Object&gt;中。</span><br><span class="line">但是你只能在List&lt;?&gt;中插入null。</span><br><span class="line">下限通配符，&lt;? Super Foo&gt;，其中Foo是任何类型，匹配Foo和Foo的超类型。</span><br></pre></td></tr></table></figure>
<p><strong>类型擦除</strong><br>在类型擦除过程中，Java编译器擦除所有类型参数，如果类型参数有界，则用其第一个边界替换每个参数，如果类型参数无界，则用Object替换。因此，生成的字节码仅包含普通的类、接口和方法。类型擦除确保不会为参数化类型创建新类。因此，泛型不会产生运行时开销。</p>
<p><strong>扩展：为什么要使用泛型</strong></p>
<ul>
<li>编译时更强的类型检查。Java编译器对泛型代码应用强类型检查，并在代码违反类型安全时发出错误。</li>
<li>消除强制类型转换。</li>
<li>能够实现通用算法。通过使用泛型，程序员可以实现适用于不同类型集合的泛型算法，可以自定义。</li>
</ul>
<p><strong>扩展：泛型的使用</strong><br>泛型类、泛型接口、泛型方法。</p>
<h3 id="4-Spring注解，怎样自定义一个注解？"><a href="#4-Spring注解，怎样自定义一个注解？" class="headerlink" title="4 Spring注解，怎样自定义一个注解？"></a>4 Spring注解，怎样自定义一个注解？</h3><p>注解是一种能被添加到Java代码中的元数据，类、方法、变量、参数和包都可以用注解来修饰。注解对于它所修饰的代码并没有直接的影响。</p>
<p><strong>自定义注解</strong></p>
<ul>
<li>使用@interface定义</li>
<li>继承元注解</li>
</ul>
<p><strong>元注解</strong><br>@Documented：将此注解包含在javadoc中。<br>@Target：表示该注解能够被应用在那些Java元素上，例如：构造器、方法、参数、属性等。<br>@Retention：定义该注解的生命周期，注解的生命周期有三个阶段：1、Java源文件阶段；2、编译到class文件阶段；3、运行期阶段。<br>@Inherited：允许子类继承父类中的注解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Autowired &#123;</span><br><span class="line">    boolean required() default true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-进程与线程"><a href="#5-进程与线程" class="headerlink" title="5 进程与线程"></a>5 进程与线程</h3><p>进程：程序的一次执行过程，是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，它有5种基本状态：初始态，执行态，等待状态，就绪状态，终止状态。</p>
<p>线程：也称为轻量级进程，是CPU调度的基本单位，线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。</p>
<p>进程是资源分配的最小单位，线程是CPU调度的最小单位。</p>
<p>区别<br>地址空间：进程拥有自己独立的地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</p>
<p>通信：线程之间的通信方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以特定的方式（IPC）进行，如：管道、套接字、消息队列。</p>
<p>影响程度：多线程程序中只要有一个线程死掉，那整个进程也死掉了；而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</p>
<p><strong>扩展：为什么引入线程</strong><br>主要是并发<br>每个进程都有自己的地址空间。在网络中，一个服务器通常需要接收大量并发请求，为每一个请求都创建一个进程，系统开销大、请求响应效率低，因此操作系统引进线程。</p>
<h3 id="6-创建多线程的方式"><a href="#6-创建多线程的方式" class="headerlink" title="6 创建多线程的方式"></a>6 创建多线程的方式</h3><p>见蔚来一面</p>
<h3 id="7-什么是线程安全？怎样保证线程安全？"><a href="#7-什么是线程安全？怎样保证线程安全？" class="headerlink" title="7 什么是线程安全？怎样保证线程安全？"></a>7 什么是线程安全？怎样保证线程安全？</h3><p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。（线程安全：在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外修改的风险。）</p>
<p>三个核心概念<br><strong>原子性</strong><br>跟数据库事务的原子性概念差不多，即一个操作或多个操作要么全部执行，要么全部都不执行。</p>
<p><strong>可见性</strong><br>当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即知道。</p>
<p>CPU从主内存中读数据的效率相对来说不高，计算机中都设有缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。</p>
<p><strong>有序性</strong><br>程序执行的顺序按照代码的先后顺序。<br>处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。<br>重排序可能会导致多线程程序出现内存可见性问题。(工作内存和主内存，编译器和处理器重排序导致的可见性）</p>
<p><strong>如何实现线程安全</strong></p>
<ul>
<li>互斥同步（synchronized）</li>
</ul>
<ol>
<li>实例方法，锁是当前实例对象。</li>
<li>静态方法，锁是当前类的Class对象。</li>
<li>代码块，锁是synchronized括号里匹配的对象。</li>
</ol>
<p>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。<br>方法级的同步是隐式的，即无需通过字节码指令来控制。JVM可以从方法常量池中的方法表结构(method_info Structure)中的ACC_SYNCHRONIZED访问标志来区分一个方法是否为同步方法。当方法调用时，调用指令将会 检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词），然后再执行方法，最后方法完成(无论是正常完成还是非正常完成)时释放monitor。</p>
<p>代码块的同步利用monitorenter和monitorexit这两个字节码指令。它们分别位于同步代码块的开始和结束位置。这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。当jvm执行到monitorenter指令时，当前线程试图获取对象的锁，如果对象未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取对象锁失败，该线程则会进入阻塞状态，直到其他线程释放锁。</p>
<p><strong>扩展：对象的内存布局</strong><br>在Hotspot虚拟机中，对象在堆内存中的存储布局可以分为3个部分：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。<br>对象头部分包括两类信息：第一类是用于存储对象自身的运行时数据（哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等）；第二类是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是那个类的实例。<br>实例数据部分是对象真正存储的有效信息，即我们在程序代码中所定义的各种类型的字段内容。<br>对齐填充仅仅起着占位符的作用。</p>
<p><strong>扩展：ReentrantLock</strong></p>
<ul>
<li><p>非阻塞同步（CAS）</p>
</li>
<li><p>无同步方案（ThreadLocal）</p>
</li>
</ul>
<p>其实引起线程不安全的根本原因就是：线程对于共享数据的更改会引起程序结果错误。<br>线程安全的解决策略就是：在多线程的情况下，保护共享数据。</p>
<h3 id="8-什么是分布式锁，怎样实现分布式锁？"><a href="#8-什么是分布式锁，怎样实现分布式锁？" class="headerlink" title="8 什么是分布式锁，怎样实现分布式锁？"></a>8 什么是分布式锁，怎样实现分布式锁？</h3><p>线程锁：主要用来给方法、代码块加锁。当某个方法或代码块使用锁时，在同一时刻仅有一个线程执行该方法或该代码块。线程锁只在同一JVM中有效果，因为线程锁的实现在根本上是依靠线程之间共享内存实现的，比如synchronized是共享对象头，Lock是共享某个变量（state）。<br>进程锁：为了控制同一操作系统中多个进程访问某个共享资源，因为进程具有独立性，各个进程无法访问其他进程的资源，因此无法通过synchronized等线程锁实现进程锁。<br>分布式锁：多个进程不在同一个系统中，用分布式锁控制多个进程对资源的访问。</p>
<p>分布式锁的三种实现方式</p>
<ul>
<li>基于数据库实现分布式锁</li>
<li>基于缓存（Redis等）实现分布式锁</li>
<li>基于Zookeeper实现分布式锁</li>
</ul>
<h3 id="9-SpringBoot怎样统一返回的数据结构"><a href="#9-SpringBoot怎样统一返回的数据结构" class="headerlink" title="9 SpringBoot怎样统一返回的数据结构"></a>9 SpringBoot怎样统一返回的数据结构</h3><p>在前后端分离的开发中，开发后端返回的数据往往是在controller层中返回的，一般都是在controller层写Restful风格的接口来返回数据。这时候返回的数据格式一般都是json格式，而且返回一般都有一个统一的数据结构形式。SpringBoot中需要创建一个自定义的统一返回处理类，来处理全局的输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">status 状态值：由后端统一定义各种返回结果的状态码。</span><br><span class="line">message 描述：本次接口调用的结果描述。</span><br><span class="line">data 数据：本次返回的数据。</span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;:&quot;100&quot;,</span><br><span class="line">  &quot;message&quot;:&quot;操作成功&quot;,</span><br><span class="line">  &quot;data&quot;:&quot;hello,hj&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>定义统一的返回结果类</li>
<li>定义状态码（枚举）</li>
<li>定义一个对全局返回的输出结果的处理类（实现ResponseBodyAdvice接口）</li>
</ol>
<h3 id="10-SpringBoot如何实现全局鉴权"><a href="#10-SpringBoot如何实现全局鉴权" class="headerlink" title="10 SpringBoot如何实现全局鉴权"></a>10 SpringBoot如何实现全局鉴权</h3><p>AOP利用一种称为”横切“的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect“，即切面。<br>所谓”切面“，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p>
<h3 id="11-权限拦截"><a href="#11-权限拦截" class="headerlink" title="11 权限拦截"></a>11 权限拦截</h3><p>同上</p>
<h3 id="12-如何理解Spring中的Bean"><a href="#12-如何理解Spring中的Bean" class="headerlink" title="12 如何理解Spring中的Bean"></a>12 如何理解Spring中的Bean</h3><h3 id="13-怎样定义一个Bean"><a href="#13-怎样定义一个Bean" class="headerlink" title="13 怎样定义一个Bean"></a>13 怎样定义一个Bean</h3><h3 id="14-Spring配置（文件）的加载顺序"><a href="#14-Spring配置（文件）的加载顺序" class="headerlink" title="14 Spring配置（文件）的加载顺序"></a>14 Spring配置（文件）的加载顺序</h3><p><strong>扩展：SpringBoot启动原理</strong></p>
<h3 id="15-HTTP协议如何告诉对方返回json格式的数据"><a href="#15-HTTP协议如何告诉对方返回json格式的数据" class="headerlink" title="15 HTTP协议如何告诉对方返回json格式的数据"></a>15 HTTP协议如何告诉对方返回json格式的数据</h3><p>请求头的Accept字段。Accept：application/json</p>
<p><strong>扩展：HTTP请求和响应报文</strong><br>HTTP请求报文：由四部分组成，分别是请求行、请求头、空行和请求体，其中空行也是组成部分之一，作用是进行分隔，必不可少。</p>
<img src="/2022/03/09/jingsuan-1/request.png" class="">
<p>第一行为请求行，由请求方法、URI和HTTP协议版本3个字段组成，它们之间用空格分隔，最后以回车和换行符结尾进行内容分割，表示接下来的内容（下一行开始的）不是请求行的内容。<br>请求头部由键/值对组成，每行一对，键和值用冒号“:”（英文）分隔。请求头部告知服务器所有有关于客户端请求的信息。<br>空行，表示请求头到此为止，下一行的内容不再是请求头。<br>请求体包含的就是请求数据，当使用的是GET方法的时候，没有请求体。</p>
<p>HTTP响应报文也由四个部分组成，分别是状态行、响应头、空行和响应正文。</p>
<img src="/2022/03/09/jingsuan-1/response.png" class="">
<p>状态行格式为：HTTP-Version Status-Code Reason-Phrase CR LF。其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。<br>响应头和请求报文的请求头类似，响应头也由键值对组成，每行一对，键和值用英文冒号:分隔。<br>空行和响应正文同请求报文。</p>
<h3 id="16-常见的Http状态码"><a href="#16-常见的Http状态码" class="headerlink" title="16 常见的Http状态码"></a>16 常见的Http状态码</h3><p>100：表示请求已被接受，需要继续处理，这是一个临时响应。<br>200：表示服务器已经成功接受请求，并将返回客户端所请求的最终结果。<br>301：永久性重定向，表示请求的资源被分配了新的URL，资源永久性地转移到了另一个位置。<br>302：临时性重定向，表示请求的资源被分配了新的URL，资源暂时性地转移到了另一个位置。<br>400：错误的请求。<br>403：服务器拒绝请求。<br>404：服务器找不到请求的资源。<br>500：服务器内部错误。<br>503：服务器不可用。</p>
<h3 id="17-Get和Post方法的区别"><a href="#17-Get和Post方法的区别" class="headerlink" title="17 Get和Post方法的区别"></a>17 Get和Post方法的区别</h3><p>GET和POST是Http协议中两种最常用的请求方法，其中，GET主要用于从服务器获取数据，POST则主要用于向服务器发送数据。<br>浏览器对于两种方法处理的第一个区别在于缓存的使用。GET请求会被浏览器主动缓存，POST则不会（除非手动设置）。get请求中如果下一次传输的数据相同，那么就会返回缓存中的内容，以求更快地展示数据。<br>第二，GET把参数拼接到url上，而POST把参数放到请求体中。GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变。<br>url的编码格式采用的是ASCII码，而不是Unicode。GET请求只接受ASCII字符的参数，而POST则没有限制。<br>GET方法的URL一般都具有长度限制，但是需要注意的是HTTP协议中并未规定GET请求的长度。这个长度限制主要是由浏览器和Web服务器所决定的，并且各个浏览器对长度的限制也各不相同。<br>GET方法只产生一个TCP数据包，浏览器会把请求头和请求数据一并发送出去，服务器响应200 ok。<br>POST方法会产生两个TCP数据包，浏览器会先将请求头发送给服务器，待服务器响应100 continue，浏览器再发送请求数据，服务器响应200 ok。<br>幂等的HTTP方法，同样的请求执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。GET，HEAD，PUT和DELETE等方法都是幂等的，而POST方法不是。</p>
<p>XMLHttpRequest是一个API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过URL来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest在AJAX中被大量使用。</p>
<h3 id="18-Https"><a href="#18-Https" class="headerlink" title="18 Https"></a>18 Https</h3><h3 id="19-一个数据表只有一个字段，按照字段排序取第二行记录、只有一行数据的话就返回一个默认值"><a href="#19-一个数据表只有一个字段，按照字段排序取第二行记录、只有一行数据的话就返回一个默认值" class="headerlink" title="19 一个数据表只有一个字段，按照字段排序取第二行记录、只有一行数据的话就返回一个默认值"></a>19 一个数据表只有一个字段，按照字段排序取第二行记录、只有一行数据的话就返回一个默认值</h3><h3 id="20-Redis如何实现排行榜"><a href="#20-Redis如何实现排行榜" class="headerlink" title="20 Redis如何实现排行榜"></a>20 Redis如何实现排行榜</h3><p>zset</p>
<h3 id="21-算法：二叉树的深度"><a href="#21-算法：二叉树的深度" class="headerlink" title="21 算法：二叉树的深度"></a>21 算法：二叉树的深度</h3><p>深度优先搜索（栈）或广度优先搜索（队列）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">dfs</span><br><span class="line">if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int l &#x3D; maxDepth(root.left);</span><br><span class="line">int r &#x3D; maxDepth(root.right);</span><br><span class="line">return Math.max(l, r) + 1;</span><br><span class="line"></span><br><span class="line">bfs</span><br><span class="line">if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int depth &#x3D; 0;</span><br><span class="line">Deque&lt;TreeNode&gt; deque &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">deque.offer(root);  &#x2F;&#x2F; 根节点入队</span><br><span class="line">while (!deque.isEmpty()) &#123;</span><br><span class="line">    int size &#x3D; deque.size();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">        TreeNode p &#x3D; deque.poll();  &#x2F;&#x2F; 节点出队</span><br><span class="line">        if (p.left !&#x3D; null) &#123;</span><br><span class="line">            deque.offer(p.left);</span><br><span class="line">        &#125;</span><br><span class="line">        if (p.right !&#x3D; null) &#123;</span><br><span class="line">            deque.offer(p.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    depth++;</span><br><span class="line">&#125;</span><br><span class="line">return depth;</span><br></pre></td></tr></table></figure>

<h3 id="22-Linux常见命令，文件权限，解释一下chmod-777-file"><a href="#22-Linux常见命令，文件权限，解释一下chmod-777-file" class="headerlink" title="22 Linux常见命令，文件权限，解释一下chmod 777 file"></a>22 Linux常见命令，文件权限，解释一下chmod 777 file</h3><p>具体见linux博客</p>
<p>Linux chmod命令（change mod）：控制用户对文件的权限<br>Linux/Unix的文件调用权限分为三级：文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。只有文件所有者和超级用户可以修改文件或目录的权限。</p>
<img src="/2022/03/09/jingsuan-1/file.png" class="">
<p>可以使用绝对模式（八进制数字模式）、符号模式指定文件的权限。</p>
<p>Linux中权限对于文件和目录的区别<br>普通文件对应的权限<br>1）可读r：表示具有读取、浏览文件内容的权限，例如，可以对文件执行cat、more、less、head、tail等文件查看命令。<br>2）可写w：表示具有新增、修改、删除[文件内容]的权限(和文件本身无关)。例如，可以对文件执行vim、echo等修改文件数据的命令。注意，无权限不赋予用户删除文件的权利，除非用户对文件的上级目录拥有写权限才可以。<br>3）可执行x：表示具有执行文件的权限。在Linux系统中，文件是否能被执行，是通过看此文件是否具有x权限来决定的。也就是说，只要文件拥有x权限，则此文件就是可执行文件。但是，文件到底能够正确运行，还要看文件中的代码是否正确。</p>
<p>目录对应的权限<br>1）可读r：浏览目录下内容，即具有读取目录结构列表的权限，也就是说，可以看到目录中有哪些文件和子目录。一旦对目录拥有r权限，就可以在此目录下执行ls命令，查看目录中的内容。<br>2）可写w：创建\修改名字\删除文件(需要有x作为前提)；对目录拥有w权限，表示可以对目录做以下操作：<br>在此目录中建立新的文件或子目录；删除已存在的文件和目录（无论子文件或子目录的权限是怎样的）；对已存在的文件或目录做更名操作；移动此目录下的文件和目录的位置。<br>一旦对目录拥有w权限，就可以在目录下执行touch、rm、cp、mv等命令。<br>3）可执行x：进入到目录的权限，目录是不能直接运行的，对目录赋予x权限，代表用户可以进入该目录，也就是说，赋予x权限的用户或群组可以使用cd命令。</p>
<h3 id="23-git代码回滚和冲突解决"><a href="#23-git代码回滚和冲突解决" class="headerlink" title="23 git代码回滚和冲突解决"></a>23 git代码回滚和冲突解决</h3><p><a target="_blank" rel="noopener" href="https://cool-jun.github.io/2022/01/08/01-08-git/">git</a></p>
<h3 id="24-如何理解区块链"><a href="#24-如何理解区块链" class="headerlink" title="24 如何理解区块链"></a>24 如何理解区块链</h3><p>账本、可追溯、不可篡改，51%攻击。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/07/weilai-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="He Jun">
      <meta itemprop="description" content="Like Sunday，Like Rain">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cool-jun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/07/weilai-1/" class="post-title-link" itemprop="url">蔚来一面</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-07 20:38:50" itemprop="dateCreated datePublished" datetime="2022-03-07T20:38:50+08:00">2022-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-20 16:20:10" itemprop="dateModified" datetime="2022-09-20T16:20:10+08:00">2022-09-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/07/weilai-1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/07/weilai-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2022年3月七号，蔚来一面。</p>
<h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1 自我介绍"></a>1 自我介绍</h3><h3 id="2-介绍项目（简历上写的）"><a href="#2-介绍项目（简历上写的）" class="headerlink" title="2 介绍项目（简历上写的）"></a>2 介绍项目（简历上写的）</h3><h3 id="3-画一下核心模块并讲解"><a href="#3-画一下核心模块并讲解" class="headerlink" title="3 画一下核心模块并讲解"></a>3 画一下核心模块并讲解</h3><h3 id="4-Java基本数据类型以及封装类"><a href="#4-Java基本数据类型以及封装类" class="headerlink" title="4 Java基本数据类型以及封装类"></a>4 Java基本数据类型以及封装类</h3><table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th align="center">boolean</th>
<th align="center">byte</th>
<th align="center">char</th>
<th align="center">short</th>
<th align="center">int</th>
<th align="center">long</th>
<th align="center">float</th>
<th align="center">double</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节数</td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">4</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">二进制位数</td>
<td align="center">1</td>
<td align="center">8</td>
<td align="center">16</td>
<td align="center">16</td>
<td align="center">32</td>
<td align="center">64</td>
<td align="center">32</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">包装类</td>
<td align="center">Boolean</td>
<td align="center">Byte</td>
<td align="center">Character</td>
<td align="center">Short</td>
<td align="center">Integer</td>
<td align="center">Long</td>
<td align="center">Float</td>
<td align="center">Double</td>
</tr>
</tbody></table>
<p>Java中为什么要为基本数据类型提供封装类呢？<br>Java是一个面相对象的编程语言，基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型。</p>
<ul>
<li>便于数据类型之间的转换。<br>int–&gt;String<br>int a = 0;<br>String result = Integer.toString(a);</li>
<li>包装类在集合中使用广泛。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
此处用int就不行，因为容器都是装“对象”的。</li>
</ul>
<p><strong>区别</strong><br>基本类型不使用new关键字，直接定义的，而包装类型需要使用new关键字来在堆中分配存储空间；<br>基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用；<br>基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null。</p>
<h3 id="5-Object类有那些函数"><a href="#5-Object类有那些函数" class="headerlink" title="5 Object类有那些函数"></a>5 Object类有那些函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public native int hashCode();</span><br><span class="line"></span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">        return (this &#x3D;&#x3D; obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected native Object clone() throws CloneNotSupportedException;</span><br><span class="line"></span><br><span class="line">public String toString() &#123;</span><br><span class="line">        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException &#123;&#125;</span><br><span class="line"></span><br><span class="line">public final native void notify();</span><br><span class="line"></span><br><span class="line">public final native void notifyAll();</span><br><span class="line"></span><br><span class="line">protected void finalize() throws Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-详细说说hashCode与equals方法"><a href="#6-详细说说hashCode与equals方法" class="headerlink" title="6 详细说说hashCode与equals方法"></a>6 详细说说hashCode与equals方法</h3><p><strong>hashCode</strong><br>hashCode()的作用是获取哈希码，也称为散列码，它实际上是返回一个int型整数。这个哈希码的作用就是确定该对象在哈希表中的索引位置。</p>
<p><strong>equals</strong><br>equals()的作用是判断两个对象是否相等，如果重写了equals()方法，比较两个对象的值是否相等，例如String、Date等类对equals方法进行了重写，比较的是所指向的对象的值；如果没有重写，比较两个对象的地址是否相等，等价于“==”。</p>
<p><a target="_blank" rel="noopener" href="https://cool-jun.github.io/2022/03/18/about-java/">联系</a></p>
<p><strong>扩展：==与equals</strong><br>==：对于基本数据类型的变量，比较其存储的“值”是否相等；对于引用类型的变量，比较的是所指向的对象的地址是否相等。<br>equlas同上。</p>
<h3 id="7-Java实现多线程的方式"><a href="#7-Java实现多线程的方式" class="headerlink" title="7 Java实现多线程的方式"></a>7 Java实现多线程的方式</h3><p>继承Thread类，重写run()方法。<br>实现Runnable接口，重写run()方法，启动线程需要通过Thread类。<br>实现Callable接口，重写call()方法来实现多线程，有返回值。<br>线程池。</p>
<h3 id="8-Runnable和Callable的区别和联系"><a href="#8-Runnable和Callable的区别和联系" class="headerlink" title="8 Runnable和Callable的区别和联系"></a>8 Runnable和Callable的区别和联系</h3><ul>
<li>Runnable中重写run方法，无法通过throws抛出异常，所有CheckedException必须在run方法内部处理。Callable中重写call方法，直接抛出Exception异常。</li>
<li>Runnable的run方法无返回值，Callable的call方法提供返回值用来表示任务运行的结果。</li>
<li>Runnable可以作为Thread构造器的参数，通过开启新的线程来执行，也可以通过线程池来执行。而Callable只能通过线程池执行。</li>
</ul>
<p><strong>Runnable使用场景</strong></p>
<ol>
<li>作为Thread类的构造参数开启新的线程，一般通过匿名内部类的方式创建线程。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread thread &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;I am a runnable task&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li>
<li>由于Java是单继承，故创建线程时一般通过实现Runnable接口，来实现run方法的具体逻辑。然后实例化，作为Thread类的构造参数开启线程。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread2 implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread(new MyThread2()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>作为线程任务提交给线程池，通过线程池维护的工作线程来执行。</li>
</ol>
<p><strong>Callable使用场景</strong><br>因为Callable的call方法提供返回值，所以当你需要知道任务执行的结果时，Callable是个不错的选择。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread3&lt;V&gt; implements Callable&lt;V&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public V call() throws Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;通过MyThread3实例化一个callable对象</span><br><span class="line">            Callable&lt;Integer&gt; callable &#x3D; new MyThread3&lt;&gt;();</span><br><span class="line">            &#x2F;&#x2F;通过callable实例化FutureTask类</span><br><span class="line">            FutureTask&lt;Integer&gt; task &#x3D; new FutureTask&lt;&gt;(callable);</span><br><span class="line">            new Thread(task).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Callable任务通过线程池的submit方法提交。且submit方法返回Future对象，通过Future的get方法可以获得具体的计算结果。而且get是个阻塞的方法，如果任务未执行完，则一直等待。</p>
<p><strong>扩展：Future和FutureTask</strong><br>对于Calleble来说，Future和FutureTask均可以用来获取任务执行结果，不过Future是个接口，FutureTask是Future的实现类，而且FutureTask还间接实现了Runnable接口，也就是说FutureTask可以作为Runnable任务提交给线程池。</p>
<h3 id="9-多线程意义？为什么要有多线程？"><a href="#9-多线程意义？为什么要有多线程？" class="headerlink" title="9 多线程意义？为什么要有多线程？"></a>9 多线程意义？为什么要有多线程？</h3><p>为了合理利用资源，解决负载均衡问题，提高CPU利用率。采用多线程的方式去同时完成几件事情而不互相干扰。</p>
<h3 id="10-并发、并行"><a href="#10-并发、并行" class="headerlink" title="10 并发、并行"></a>10 并发、并行</h3><p>并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p>
<p>并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。同一时刻，有多条指令在多个处理器上同时执行。微观和宏观上来看，二者都是一起执行的。</p>
<h3 id="11-BIO与NIO、Channel、多路复用"><a href="#11-BIO与NIO、Channel、多路复用" class="headerlink" title="11 BIO与NIO、Channel、多路复用"></a>11 BIO与NIO、Channel、多路复用</h3><p><a target="_blank" rel="noopener" href="https://cool-jun.github.io/2021/11/14/11-14-Java/">IO</a></p>
<h3 id="12-JVM"><a href="#12-JVM" class="headerlink" title="12 JVM"></a>12 JVM</h3><p><a target="_blank" rel="noopener" href="https://cool-jun.github.io/2021/11/27/11-27-Java/">jvm</a></p>
<h3 id="13-垃圾回收机制"><a href="#13-垃圾回收机制" class="headerlink" title="13 垃圾回收机制"></a>13 垃圾回收机制</h3><p><a target="_blank" rel="noopener" href="https://cool-jun.github.io/2021/12/01/12-01-Java/">gc</a><br><a target="_blank" rel="noopener" href="https://cool-jun.github.io/2021/12/04/12-04-Java/">gc_jvm</a></p>
<h3 id="14-MySQL隔离级别，详细讲讲"><a href="#14-MySQL隔离级别，详细讲讲" class="headerlink" title="14 MySQL隔离级别，详细讲讲"></a>14 MySQL隔离级别，详细讲讲</h3><h3 id="15-算法题"><a href="#15-算法题" class="headerlink" title="15 算法题"></a>15 算法题</h3><p><strong>快排</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void quickSort(int[] nums, int low, int high) &#123;</span><br><span class="line">    if (low &lt; high) &#123;</span><br><span class="line">        int pos &#x3D; partition(nums, low, high);  &#x2F;&#x2F; 划分子数组的位置</span><br><span class="line">        quickSort(nums, low, pos - 1);    &#x2F;&#x2F; 左子数组递归调用</span><br><span class="line">        quickSort(nums, pos + 1, high);    &#x2F;&#x2F; 右子数组递归调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int partition(int[] nums, int low, int high) &#123;</span><br><span class="line">    int pivot &#x3D; nums[low];  &#x2F;&#x2F; 基准元素</span><br><span class="line">    while (low &lt; high) &#123;</span><br><span class="line">        while (low &lt; high &amp;&amp; nums[high] &gt;&#x3D; pivot) &#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果nums[j]小于基准元素，nums[i] &#x3D; nums[j]</span><br><span class="line">        nums[low] &#x3D; nums[high];</span><br><span class="line"></span><br><span class="line">        while (low &lt; high &amp;&amp; nums[low] &lt;&#x3D; pivot) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果nums[i]大于基准元素，nums[j] &#x3D; nums[i]</span><br><span class="line">        nums[high] &#x3D; nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 基准元素将数据分成2部分</span><br><span class="line">    nums[low] &#x3D; pivot;</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>谁是幸运儿</strong><br>题目描述：<br>小A是某公司的员工，在一次公司年会上，主持人宣布进行一项游戏来活跃年会气氛，游戏规则如下：n个人随机站成一排，按照他们所站的顺序依次给他们编号从1到n，接下来就从编号为1的人开始，按从左到右的顺序每隔一人选出一个人，选出的这些被淘汰，剩下的需要重新站成一排，其中首尾是接龙的，即如果倒数第二个被淘汰，则隔一人即第一个人被淘汰，如此循环一直到最后剩下两个人为止，那么这剩下的最后两个人就是本场晚会的幸运儿，得到神秘大奖，小A想成为这个幸运儿，请你帮小A算出来开始时他应该站在什么位置才最终可以成为幸运儿。（3&lt;=n&lt;=50）<br>输入<br>开始的进行游戏的总人数n<br>输出<br>第一行是选出顺序，第二行是两名幸运儿的初始位置（按升序排列），要求位置编号之间用一个空格空开。</p>
<p>样例输入<br>5<br>样例输出<br>2 4 1<br>5 3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class ListBoy &#123;</span><br><span class="line">    ListBoy next;</span><br><span class="line">    int elem;</span><br><span class="line">    public ListBoy() &#123;&#125;</span><br><span class="line">    public ListBoy(int elem) &#123;</span><br><span class="line">        this.elem &#x3D; elem;</span><br><span class="line">    &#125;</span><br><span class="line">    public ListBoy(int elem, ListBoy next) &#123;</span><br><span class="line">        this.elem &#x3D; elem;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 分析：环形链表</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner cin &#x3D; new Scanner(System.in);</span><br><span class="line">        int n &#x3D; cin.nextInt();</span><br><span class="line"></span><br><span class="line">        ListBoy head &#x3D; null, p &#x3D; null;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            if (i &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                p &#x3D; new ListBoy(i);</span><br><span class="line">                head &#x3D; p;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                p.next &#x3D; new ListBoy(i);</span><br><span class="line">                p &#x3D; p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next &#x3D; head;  &#x2F;&#x2F; 尾结点指向头结点</span><br><span class="line">        p &#x3D; head;</span><br><span class="line"></span><br><span class="line">        while (p.next.next !&#x3D; p) &#123;</span><br><span class="line">            System.out.printf(&quot;%d &quot;, p.next.elem);</span><br><span class="line">            p.next &#x3D; p.next.next;</span><br><span class="line">            p &#x3D; p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.printf(&quot;%d &quot;, p.next.elem);</span><br><span class="line">        System.out.printf(&quot;%d&quot;, p.elem);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/03/ymy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="He Jun">
      <meta itemprop="description" content="Like Sunday，Like Rain">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cool-jun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/03/ymy/" class="post-title-link" itemprop="url">圆明园</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-03 14:17:30" itemprop="dateCreated datePublished" datetime="2022-03-03T14:17:30+08:00">2022-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-15 20:32:27" itemprop="dateModified" datetime="2022-03-15T20:32:27+08:00">2022-03-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%94%9F%E6%B4%BB/" itemprop="url" rel="index"><span itemprop="name">生活</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/03/ymy/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/03/ymy/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>圆明园游记！<br>虽漫天大雪，吾往矣。</p>
<p>入园后，园内破败的建筑与墙上绘画着的昔日辉煌遥相呼应，历史书上八国联军侵华的一幕又在脑海浮起。落后就要挨打，就要受欺负。走着走着，雪愈发下的紧了，衬托着如今的荒凉，也告诉我们勿忘历史，砥砺前行！</p>
<p>大水法</p>
<img src="/2022/03/03/ymy/ymy.jpg" class="">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/18/02-18-Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="He Jun">
      <meta itemprop="description" content="Like Sunday，Like Rain">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cool-jun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/18/02-18-Spring/" class="post-title-link" itemprop="url">annotation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-18 20:16:34" itemprop="dateCreated datePublished" datetime="2022-02-18T20:16:34+08:00">2022-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-15 21:25:16" itemprop="dateModified" datetime="2022-03-15T21:25:16+08:00">2022-03-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/18/02-18-Spring/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/18/02-18-Spring/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-SpringBootApplication"><a href="#1-SpringBootApplication" class="headerlink" title="1 @SpringBootApplication"></a>1 @SpringBootApplication</h3><p>这是Spring Boot最最最核心的注解，用在Spring Boot主类上，标识这是一个Spring Boot应用，用来开启Spring Boot。<br>这个注解是@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan这三个注解的组合，也可以用这三个注解来代替@SpringBootApplication注解。<br>@Configuration：Spring 3.0添加的一个注解，用来代替applicationContext.xml配置文件，所有这个配置文件里面能做到的事情都可以通过这个注解所在类来完成。</p>
<ul>
<li>@SpringBootConfiguration：@Configuration注解的变体，用来修饰Spring Boot配置。</li>
<li>@EnableAutoConfiguration：允许Spring Boot自动配置注解，开启这个注解之后，Spring Boot就能根据当前类路径下的包或者类来配置Spring Bean。</li>
<li>@ComponentScan：Spring 3.1添加的一个注解，用来代替配置文件中的component-scan配置，开启组件扫描，即自动扫描包路径下的@Component注解进行注册bean实例到context中。</li>
</ul>
<h3 id="2-RestController"><a href="#2-RestController" class="headerlink" title="2 @RestController"></a>2 @RestController</h3><p>@Controller用于标记一个类，使用它标记的类就是一个Spring MVC Controller对象，处理器会扫描使用该注解的类的方法，并检测该方法是否使用了@RequestMapping注解。</p>
<p>@ResponseBody注解用于将@Controller修饰的类的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区，通常用来返回JSON或者XML数据，返回JSON数据的情况比较多。</p>
<p>@RestController=@Controller+@ResponseBody</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/13/01-13-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="He Jun">
      <meta itemprop="description" content="Like Sunday，Like Rain">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cool-jun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/13/01-13-sort/" class="post-title-link" itemprop="url">sort</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-13 19:31:36" itemprop="dateCreated datePublished" datetime="2022-01-13T19:31:36+08:00">2022-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-07 18:25:47" itemprop="dateModified" datetime="2022-09-07T18:25:47+08:00">2022-09-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/sort/" itemprop="url" rel="index"><span itemprop="name">sort</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/13/01-13-sort/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/13/01-13-sort/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-排序算法分类"><a href="#1-排序算法分类" class="headerlink" title="1 排序算法分类"></a>1 排序算法分类</h3><img src="/2022/01/13/01-13-sort/sort.png" class="">

<h3 id="2-内部排序和外部排序"><a href="#2-内部排序和外部排序" class="headerlink" title="2 内部排序和外部排序"></a>2 内部排序和外部排序</h3><p>排序有内部排序和外部排序，内部排序是指数据记录在内存中进行排序，而外部排序是指因为排序的数据很大，内存一次不能容纳全部的排序记录，在排序过程中需要访问外存。<br>我们通常所说的排序算法往往指的是内部排序算法，即数据记录在内存中进行排序。</p>
<h3 id="3-比较和非比较"><a href="#3-比较和非比较" class="headerlink" title="3 比较和非比较"></a>3 比较和非比较</h3><p>常见的如快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果中，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。<br>比较排序的优势：适用于各种规模的数据，也不在乎数据的分布，都能进行排序。</p>
<p>计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。<br>非比较排序只要确定每个元素之前的已有的元素个数即可，一次遍历解决，时间复杂度O(n)。<br>非比较排序的时间复杂度低，但由于非比较排序需要占用空间来确定唯一的位置。所以对数据规模和数据分布有一定的要求。</p>
<h3 id="4-常用排序算法总结"><a href="#4-常用排序算法总结" class="headerlink" title="4 常用排序算法总结"></a>4 常用排序算法总结</h3><table>
<thead>
<tr>
<th>排序算法</th>
<th align="center">平均时间复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>直接插入排序</td>
<td align="center">o(n^2)</td>
<td align="center">o(n)</td>
<td align="center">o(n^2)</td>
<td align="center">o(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td align="center">o(n^1.3)~o(n^2)</td>
<td align="center">o(n^1.3)</td>
<td align="center">o(n^2)</td>
<td align="center">o(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td>简单选择排序</td>
<td align="center">o(n^2)</td>
<td align="center">o(n^2)</td>
<td align="center">o(n^2)</td>
<td align="center">o(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td align="center">o(nlogn)</td>
<td align="center">o(nlogn)</td>
<td align="center">o(nlogn)</td>
<td align="center">o(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td align="center">o(n^2)</td>
<td align="center">o(n)</td>
<td align="center">o(n^2)</td>
<td align="center">o(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td align="center">o(nlogn)</td>
<td align="center">o(nlogn)</td>
<td align="center">o(n^2)</td>
<td align="center">o(logn)~o(n)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td align="center">o(nlogn)</td>
<td align="center">o(nlogn)</td>
<td align="center">o(nlogn)</td>
<td align="center">o(n)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td align="center">o(d(n+r))</td>
<td align="center">o(d(n+r))</td>
<td align="center">o(d(n+r))</td>
<td align="center">o(n+r)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<h3 id="5-冒泡排序与快速排序"><a href="#5-冒泡排序与快速排序" class="headerlink" title="5 冒泡排序与快速排序"></a>5 冒泡排序与快速排序</h3><p><strong>冒泡排序</strong><br>每次比较相邻的两个元素，如果它们的顺序错误就把他们交换。<br>n个数需要进行n-1趟排序。每一趟只能确定一个数的位置，如果有n个数进行排序，只需将n-1个数置于正确位置，也就是说要进行n-1趟操作，而每一趟操作都需要从第1位开始进行相邻两个数的比较。</p>
<p>优化：当第i趟冒泡排序一次都没有交换，说明该序列已经有序了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public int[] bubbleSort(int[] nums) &#123;</span><br><span class="line">        if (nums.length &lt; 2) &#123;</span><br><span class="line">            return nums;</span><br><span class="line">        &#125;</span><br><span class="line">        int flag &#x3D; 0;  &#x2F;&#x2F; 表示序列是否交换</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.length - 1; i++) &#123;</span><br><span class="line">            flag &#x3D; 0;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; nums.length - i - 1; j++) &#123;</span><br><span class="line">                if (nums[j] &gt; nums[j + 1]) &#123;</span><br><span class="line">                    int temp &#x3D; nums[j];</span><br><span class="line">                    nums[j] &#x3D; nums[j + 1];</span><br><span class="line">                    nums[j + 1] &#x3D; temp;</span><br><span class="line">                    flag &#x3D; 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 一次都没有交换，说明该序列已经有序了</span><br><span class="line">            if (flag &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>快速排序</strong><br>快速排序基于分治的思想，通过一趟排序将要排序的数据分割成独立的两部分：分割点左边都是比它小的数，右边都是比它大的数。然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据有序。</p>
<p>快速排序的优化<br>基准元素的选取：固定位置选取、随机位置选取、三数取中法。<br>优化小数组时的排序方案：当局部排序数组长度较小时，采用插入排序，因为长度分割到够小后，继续分割的效率要低于直接插入排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class QuickSort &#123;</span><br><span class="line">    &#x2F;&#x2F; 快速排序基于分治的思想，通过一趟排序将要排序的数据分割成独立的两部分：</span><br><span class="line">    &#x2F;&#x2F; 分割点左边都是比它小的数，右边都是比它大的数。</span><br><span class="line">    &#x2F;&#x2F; 然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，</span><br><span class="line">    &#x2F;&#x2F; 以此达到整个数据有序。</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 快速排序的优化</span><br><span class="line">    &#x2F;&#x2F; 基准元素的选取：固定位置选取、随机位置选取、三数取中法</span><br><span class="line">    &#x2F;&#x2F; 优化小数组时的排序方案：当局部排序数组长度较小时，采用插入排序，</span><br><span class="line">    &#x2F;&#x2F; 因为长度分割到够小后，继续分割的效率要低于直接插入排序</span><br><span class="line">    public void quickSort(int[] nums, int low, int high) &#123;</span><br><span class="line">        if (low &lt; high) &#123;</span><br><span class="line">            int pos &#x3D; partition(nums, low, high);  &#x2F;&#x2F; 划分子数组的位置</span><br><span class="line">            quickSort(nums, low, pos - 1);    &#x2F;&#x2F; 左子数组递归调用</span><br><span class="line">            quickSort(nums, pos + 1, high);    &#x2F;&#x2F; 右子数组递归调用</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int partition(int[] nums, int low, int high) &#123;</span><br><span class="line">        int pivot &#x3D; nums[low];  &#x2F;&#x2F; 基准元素</span><br><span class="line">        while (low &lt; high) &#123;</span><br><span class="line">            while (low &lt; high &amp;&amp; nums[high] &gt;&#x3D; pivot) &#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[low] &#x3D; nums[high];</span><br><span class="line"></span><br><span class="line">            while (low &lt; high &amp;&amp; nums[low] &lt;&#x3D; pivot) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[high] &#x3D; nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 基准元素将数据分成2部分</span><br><span class="line">        nums[low] &#x3D; pivot;</span><br><span class="line">        &#x2F;&#x2F; 返回下标</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6 归并排序"></a>6 归并排序</h3><p>归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法，该算法是采用分治思想的一个非常典型的应用。<br>分解–&gt;合并<br>它将已经有序的子序列合并，得到完全有序的序列。即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。归并排序是一种稳定的排序方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void merge(int[] nums, int l, int mid, int r, int[] temp) &#123;</span><br><span class="line">        int i &#x3D; l, j &#x3D; mid + 1;  &#x2F;&#x2F; 左边序列和右边序列下标指针</span><br><span class="line">        int t &#x3D; 0;  &#x2F;&#x2F; 临时数组下标指针</span><br><span class="line">        while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; r) &#123;</span><br><span class="line">            if (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">                temp[t++] &#x3D; nums[i++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp[t++] &#x3D; nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 若左边序列还有元素，将其拷贝至数组temp</span><br><span class="line">        while (i &lt;&#x3D; mid) &#123;</span><br><span class="line">            temp[t++] &#x3D; nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 若右边序列还有元素，将其拷贝至数组temp</span><br><span class="line">        while (j &lt;&#x3D; r) &#123;</span><br><span class="line">            temp[t++] &#x3D; nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 将temp中元素拷贝至原数组</span><br><span class="line">        t &#x3D; 0;</span><br><span class="line">        while (l &lt;&#x3D; r) &#123;</span><br><span class="line">            nums[l++] &#x3D; temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void mergeSort(int[] nums, int l, int r, int[] temp) &#123;</span><br><span class="line">        if (l &lt; r) &#123;</span><br><span class="line">            int mid &#x3D; (l + r) &#x2F; 2;</span><br><span class="line">            mergeSort(nums, l, mid, temp);  &#x2F;&#x2F; 对左边序列进行归并排序</span><br><span class="line">            mergeSort(nums, mid+1, r, temp);  &#x2F;&#x2F; 对右边序列进行归并排序</span><br><span class="line">            merge(nums, l, mid, r, temp);  &#x2F;&#x2F; 合并两个有序序列</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-直接插入排序与希尔排序"><a href="#7-直接插入排序与希尔排序" class="headerlink" title="7 直接插入排序与希尔排序"></a>7 直接插入排序与希尔排序</h3><p><strong>直接插入排序</strong><br>把n个待排序的元素看成一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。<br>将一个记录插入到已排序好的有序表中，从而得到一个新的、记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 直接插入排序</span><br><span class="line">    &#x2F;&#x2F; 将一个记录插入到已排序好的有序表中，从而得到一个新的、记录数增1的有序表。</span><br><span class="line">    &#x2F;&#x2F; 先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，</span><br><span class="line">    &#x2F;&#x2F; 直至整个序列有序为止。</span><br><span class="line">    &#x2F;&#x2F; 局部有序--&gt;全局有序</span><br><span class="line">    public void insertSort(int[] nums) &#123;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] &lt; nums[i-1]) &#123;</span><br><span class="line">                int temp &#x3D; nums[i];  &#x2F;&#x2F; 设置哨兵，保存待插入元素</span><br><span class="line">                int j &#x3D; i - 1;</span><br><span class="line">                &#x2F;&#x2F; 元素后移，直到找到插入位置</span><br><span class="line">                while (j &gt;&#x3D; 0 &amp;&amp; temp &lt; nums[j]) &#123;</span><br><span class="line">                    nums[j+1] &#x3D; nums[j];</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[j+1] &#x3D; temp;  &#x2F;&#x2F; 插入正确位置</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>希尔排序</strong><br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 希尔排序（缩小增量排序）</span><br><span class="line">    public void shellSort(int[] nums) &#123;</span><br><span class="line">        &#x2F;&#x2F; gap 增量</span><br><span class="line">        for (int gap &#x3D; nums.length &#x2F; 2; gap &gt; 0; gap &#x2F;&#x3D; 2) &#123;</span><br><span class="line">            &#x2F;&#x2F; 对一个增量区间进行比较</span><br><span class="line">            &#x2F;&#x2F; 例如：</span><br><span class="line">            &#x2F;&#x2F; 3  4  5  1  2  6</span><br><span class="line">            &#x2F;&#x2F; |--|--|--^  ^  ^</span><br><span class="line">            &#x2F;&#x2F;    |--|-----|  |</span><br><span class="line">            &#x2F;&#x2F;       |--------|</span><br><span class="line">            for (int i &#x3D; gap; i &lt; nums.length; i++) &#123;</span><br><span class="line">                int temp &#x3D; nums[i];</span><br><span class="line">                int j &#x3D; i - gap;  &#x2F;&#x2F;每组内其它元素下标</span><br><span class="line">                while (j &gt;&#x3D; 0 &amp;&amp; temp &lt; nums[j]) &#123;</span><br><span class="line">                    nums[j + gap] &#x3D; nums[j];  &#x2F;&#x2F; j为左区间的取值，j+gap为右区间与左区间的对应值</span><br><span class="line">                    j -&#x3D; gap;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[j + gap] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-简单选择排序与堆排序"><a href="#8-简单选择排序与堆排序" class="headerlink" title="8 简单选择排序与堆排序"></a>8 简单选择排序与堆排序</h3><p><strong>简单选择排序</strong><br>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void selectSort(int[] nums) &#123;</span><br><span class="line">        int min;  &#x2F;&#x2F; 记录每一趟最小值的下标</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.length - 1; i++) &#123;</span><br><span class="line">            min &#x3D; i;</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; nums.length; j++) &#123;</span><br><span class="line">                if (nums[min] &gt; nums[j]) &#123;</span><br><span class="line">                    min &#x3D; j;  &#x2F;&#x2F; 找到最小值的下标</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (min !&#x3D; i) &#123;</span><br><span class="line">                int temp &#x3D; nums[min];</span><br><span class="line">                nums[min] &#x3D; nums[i];</span><br><span class="line">                nums[i] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>堆排序</strong><br>堆是具有以下性质的完全二叉树：<br>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p>
<p>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]<br>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</p>
<p>堆排序的基本思想：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列。</p>
<p>对于一个完全二叉树，在填满和未填满的情况下，第一个叶子节点的索引一定是序列长度/2，最后一个非叶子节点的索引一定是第一个叶子结点的索引值-1（根节点索引为0）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static void heapSort(int[] arr) &#123;</span><br><span class="line">    &#x2F;&#x2F; 以升序排列为例，构建大顶堆</span><br><span class="line">    for (int i &#x3D; arr.length &#x2F; 2 - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        adjustHeap(arr, i, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp &#x3D; 0;</span><br><span class="line">    for (int j &#x3D; arr.length - 1; j &gt; 0; j--) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将堆顶元素与末尾元素交换</span><br><span class="line">        temp &#x3D; arr[j];</span><br><span class="line">        arr[j] &#x3D; arr[0];</span><br><span class="line">        arr[0] &#x3D; temp;</span><br><span class="line">        &#x2F;&#x2F; 重新对堆进行调整</span><br><span class="line">        adjustHeap(arr, 0, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 调整大顶堆</span><br><span class="line"> * @param arr</span><br><span class="line"> * @param i  非叶子节点在数组中的索引</span><br><span class="line"> * @param len  对多少个元素进行调整</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void adjustHeap(int[] arr, int i, int len) &#123;</span><br><span class="line">    int temp &#x3D; arr[i];</span><br><span class="line">    for (int k &#x3D; i * 2 + 1; k &lt; len; k &#x3D; k * 2 + 1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 从i结点的左子结点开始，也就是2i+1处开始</span><br><span class="line">        &#x2F;&#x2F; 如果左子结点小于右子结点，k指向右子结点</span><br><span class="line">        if (k + 1 &lt; len &amp;&amp; arr[k] &lt; arr[k + 1]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果子节点大于父节点，将子节点值赋给父节点</span><br><span class="line">        if (arr[k] &gt; temp) &#123;</span><br><span class="line">            arr[i] &#x3D; arr[k];</span><br><span class="line">            &#x2F;&#x2F; 继续循环比较</span><br><span class="line">            i &#x3D; k;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/08/01-08-git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="He Jun">
      <meta itemprop="description" content="Like Sunday，Like Rain">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cool-jun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/08/01-08-git/" class="post-title-link" itemprop="url">git</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-08 16:26:36" itemprop="dateCreated datePublished" datetime="2022-01-08T16:26:36+08:00">2022-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-16 16:08:43" itemprop="dateModified" datetime="2022-04-16T16:08:43+08:00">2022-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tool/" itemprop="url" rel="index"><span itemprop="name">Tool</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/01/08/01-08-git/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/08/01-08-git/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Git</strong><br>Git是一种分布式版本控制系统（Distributed Version Control System，DVCS），分为两种类型的仓库：本地仓库和远程仓库。</p>
<p>本地仓库：开发人员自己电脑上的Git仓库。<br>远程仓库：远程服务器上的Git仓库。</p>
<p>clone：就是将远程仓库代码复制到本地仓库。<br>push：就是将本地仓库代码上传到远程仓库。<br>pull：就是将远程仓库代码下载到本地仓库。</p>
<p><strong>Git工作区、暂存区和版本库</strong></p>
<ul>
<li>工作区：就是电脑里存放项目代码的地方。</li>
<li>暂存区：英文叫stage或index。一般存放在.git目录下的index文件（.git/index）中，暂存区有时也叫作索引（index）。用于临时存放你的改动，它只是一个文件，保存即将提交的文件列表信息。</li>
<li>版本库（repository）：存放已提交的数据，这里边有你提交的所有版本的数据，push的时候，就是把这个区的数据push到远程仓库。其中，HEAD指向最新放入仓库的版本。</li>
</ul>
<p>工作流程：<br>在工作目录中添加、修改文件；<br>将需要进行版本管理的文件放入暂存区；<br>将暂存区的文件提交到版本库；<br>push到远端仓库。</p>
<img src="/2022/01/08/01-08-git/git.png" class="">
<p>Git管理的文件有三种状态：已修改（modified）、已暂存（staged）和已提交（committed）。</p>
<p>将工作区的代码存放到暂存区：<br>git add . （将当前工作区的所有文件存放到暂存区）<br>git add -u （提交更新所有改变的文件，即提交所有变化的文件）<br>git add -A （提交已被修改和已被删除文件，但是不包括新的文件）</p>
<p><strong>stage</strong><br>修改了4个文件，在不放弃任何修改的情况下，其中一个文件不想提交，如何操作？<br>（没add : git add；已经add: git reset –soft ）</p>
<p>修改到一半的文件，突然间不需要或者放弃修改了，怎么恢复未修改前文件？<br>(git checkout)</p>
<p>代码写一半，被打断去做其他功能开发，未完成代码保存？<br>(git stash)能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录。</p>
<p>代码写一半，发现忘记切换分支了？<br>(git stash &amp; git checkout)</p>
<p>代码需要回滚了？<br>（git reset）</p>
<p><strong>常用命令</strong><br>备份当前工作区的内容<br>git stash</p>
<p>从远程仓库克隆<br>git clone [url]</p>
<p>从远程仓库中抓取与拉取<br>git fetch 是从远程仓库获取最新版本到本地仓库，不会自动merge。<br>git pull 是从远程仓库获取最新版本并merge到本地仓库。</p>
<p>推送到远程仓库<br>git push remote-name branch-name</p>
<p><strong>Git分支</strong><br>列出所有本地分支<br>git branch<br>列出所有远程分支<br>git branch -r<br>列出所有本地分支和远程分支<br>git branch -a<br>创建分支<br>git branch [branch_name]<br>切换分支<br>git checkout [branch_name]<br>合并分支<br>git merge [branch_name]</p>
<p><strong>rebase</strong><br>假设现在有两个分支master和hj，其中hj是在提交点B处从master上拉出的分支，master上有一个新提交M，hj上有两个新提交C和D。<br>此时要切换到hj分支上，执行如下命令，相当于是想要把master分支合并到hj分支（可以类比为我们在自己的分支hj上开发了一段时间，现在准备从主干master上拉一下最新改动）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout hj</span><br><span class="line">git rebase master</span><br><span class="line">等价于git rebase master hj</span><br></pre></td></tr></table></figure>
<img src="/2022/01/08/01-08-git/rebase.png" class="">
<ul>
<li>hj：待变基分支、当前分支</li>
<li>master：基分支、目标分支</li>
</ul>
<p>当执行rebase操作时，git会从两个分支的共同祖先开始提取待变基分支上的修改，然后将待变基分支指向基分支的最新提交，最后将刚才提取的修改应用到基分支的最新提交的后面。</p>
<p>场景：张三从B拉了代码进行开发，目前提交了两次，开发到D了；李四也从B拉代码开发并且开发完毕，他提交到了M，然后合到主干上了。<br>此时张三想拉下最新代码，于是他在hj分支上执行了git rebase master，即把master分支给rebase过来，由于李四更早开发完并合了主干，如此就相当于张三是基于李四的最新提交M进行的开发了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/29/12-29-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="He Jun">
      <meta itemprop="description" content="Like Sunday，Like Rain">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cool-jun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/29/12-29-Tree/" class="post-title-link" itemprop="url">Tree</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-29 11:19:28" itemprop="dateCreated datePublished" datetime="2021-12-29T11:19:28+08:00">2021-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-15 20:48:55" itemprop="dateModified" datetime="2022-03-15T20:48:55+08:00">2022-03-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/12/29/12-29-Tree/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/12/29/12-29-Tree/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1 二叉树"></a>1 二叉树</h3><p>1）每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。<br>2）左子树和右子树是有顺序的，次序不能颠倒。<br>3）即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。</p>
<p>性质：<br>1）在二叉树的第i层上最多有2^(i-1)个节点（i&gt;=1）。<br>2）二叉树深度为k，那么最多有2^k-1个节点（k&gt;=1）。<br>3）n0=n2+1。n0表示度数为0的节点个数（叶子节点个数），n2表示度数为2的节点个数。<br>4）在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。<br>5）若对含n个结点的完全二叉树从上到下且从左至右进行1至n的编号，则对完全二叉树中任意一个编号为i的结点有如下特性：<br>(1) 若i=1，则该结点是二叉树的根，无双亲，否则，编号为[i/2]的结点为其双亲结点;<br>(2) 若2i&gt;n，则该结点无左孩子，否则，编号为2i的结点为其左孩子结点；<br>(3) 若2i+1&gt;n，则该结点无右孩子结点，否则，编号为2i+1的结点为其右孩子结点。</p>
<h3 id="2-满二叉树"><a href="#2-满二叉树" class="headerlink" title="2 满二叉树"></a>2 满二叉树</h3><p>高度为h，由2^h-1个节点构成的二叉树称为满二叉树。</p>
<h3 id="3-完全二叉树"><a href="#3-完全二叉树" class="headerlink" title="3 完全二叉树"></a>3 完全二叉树</h3><p>完全二叉树是由满二叉树引出来的，若设二叉树的高度为h，则除第 h 层外，其它各层 (1～h-1) 的结点个数都达到最大值(即1~h-1层为一个满二叉树)，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p>
<h3 id="4-平衡二叉树（AVL树）"><a href="#4-平衡二叉树（AVL树）" class="headerlink" title="4 平衡二叉树（AVL树）"></a>4 平衡二叉树（AVL树）</h3><p>它是一棵空树或者它的左右两棵子树的高度差的绝对值不超过1，并且左右两棵子树都是一棵平衡二叉树。</p>
<h3 id="5-二叉排序树（二叉搜索树-二叉查找树）BST"><a href="#5-二叉排序树（二叉搜索树-二叉查找树）BST" class="headerlink" title="5 二叉排序树（二叉搜索树/二叉查找树）BST"></a>5 二叉排序树（二叉搜索树/二叉查找树）BST</h3><p>它是一棵空树，或者是具有下列性质的二叉树：<br>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>（3）左、右子树也分别为二叉排序树；<br>（4）一般来说没有键值相等的结点。</p>
<h3 id="6-红黑树"><a href="#6-红黑树" class="headerlink" title="6 红黑树"></a>6 红黑树</h3><p>红黑树（Red Black Tree）是一种自平衡二叉查找树。红黑树是一种含有红黑结点并且能自平衡的二叉查找树。它必须满足下面性质：<br>性质1：每个结点要么是黑色，要么是红色。<br>性质2：根结点是黑色。<br>性质3：每个叶子结点（NIL）都是黑色。<br>性质4：每个红色结点的两个子结点一定都是黑色。<br>性质5：任意一个结点到每个叶子结点的路径都包含数量相同的黑色结点。<br>如果一个结点存在黑色子结点，那么该结点肯定有两个子结点。</p>
<p>应用：TreeMap、TreeSet、JDK1.8 HashMap</p>
<p><strong>红黑树vs平衡二叉树</strong><br>红黑树不追求”完全平衡”，它不像AVL树那样要求节点的|balFact| &lt;= 1，它只要求部分达到平衡。红黑树是用非严格的平衡来换取增删节点时旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL树是严格的平衡树，因此在增加或者删除节点的时候，旋转的次数比红黑树要多。</p>
<p>红黑树的查询性能略微逊色于AVL树，但是，红黑树在插入和删除上优于AVL树，AVL树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于AVL树为了维持平衡的开销要小得多。<br>实际应用中，若搜索的次数远大于插入和删除，那么选择AVL树；如果搜索，插入，删除次数几乎差不多，应该选择红黑树。</p>
<h3 id="7-B树、B-树"><a href="#7-B树、B-树" class="headerlink" title="7 B树、B+树"></a>7 B树、B+树</h3><p><strong>B树</strong><br>一棵m阶B树是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树：<br>1、根结点至少有两棵子树；<br>2、树中每个结点至多有m棵子树；<br>3、除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加一。<br>4、所有结点都包含如下形式的数据：(n,A0 ,K1 ,A1 ,K2 ,A2 , … ,Kn,An )<br>其中n为关键字的个数，Ki(i=1, … , n)为关键字，且满足K1&lt;K2&lt;…&lt;Kn。Ai( i=0,1, … , n)为指向子树根结点的指针，且对于i=1,2, … , n-1，Ai所指子树上各结点的一切关键字均大于Ki，而小于Ki+1。A0所指子树上各结点的一切关键字均小于K1，An所指子树上各结点的一切关键字均大于Kn。<br>对于叶子结点，所有指针Ai皆为空。对于具有n个关键字的非叶结点，将有n+1棵子树。</p>
<p><strong>B+树</strong><br>1.有n棵子树的结点中含有n个关键字；<br>2.根节点至少有一棵子树，除根节点外，其他结点至少有[ m/2 ]棵子树；<br>3.所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字信息的指针，且叶子结点依关键字的大小自小而大顺序链接。(而B树的叶子节点并没有包括全部关键字的信息)<br>4.所有的非叶子结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。</p>
<p>B+树的搜索与B树基本相同，区别是B+树只有到达叶子结点才能命中（B树可以在非叶子结点命中）。<br>B树的优势是当你要查找的值恰好处在一个非叶子节点时，查找到该节点就成功返回并结束查询。<br>而B+树由于非叶子节点只是索引部分，这些节点中只含有其子树中的最大(或最小)关键字，当非终端节点上的关键字等于给点值时，查找并不终止，而是继续向下直到叶子节点。因此在B+树中，无论查找成功与否，都是走了一条从根到叶子节点的路径。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/27/12-27-desgin-mode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="He Jun">
      <meta itemprop="description" content="Like Sunday，Like Rain">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cool-jun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/27/12-27-desgin-mode/" class="post-title-link" itemprop="url">desgin_mode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-27 21:32:13" itemprop="dateCreated datePublished" datetime="2021-12-27T21:32:13+08:00">2021-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-29 11:29:15" itemprop="dateModified" datetime="2022-03-29T11:29:15+08:00">2022-03-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/12/27/12-27-desgin-mode/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/12/27/12-27-desgin-mode/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-设计模式分类"><a href="#1-设计模式分类" class="headerlink" title="1 设计模式分类"></a>1 设计模式分类</h3><p>设计模式一般分为三类：</p>
<ul>
<li>创建型模式（五种）：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li>
<li>结构型模式（七种）：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li>
<li>行为型模式（十一种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ul>
<h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2 工厂模式"></a>2 工厂模式</h3><p>工厂模式有3种不同的实现方式，分别是简单工厂模式、工厂方法模式和抽象工厂模式。</p>
<p><strong>简单工厂模式</strong><br>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只需要一个工厂类就可以完成，这种模式叫“简单工厂模式”。<br>简单工厂模式有一个具体的工厂类，可以生产多个不同的产品。<br>简单工厂模式有一个问题，类的创建依赖工厂类。也就是说，如果想要拓展程序（增加一个产品），必须对工厂类进行修改，这违背了开闭原则。</p>
<p><strong>工厂方法模式</strong><br>定义了一个创建对象的抽象方法，由子类决定要实例化的类。<strong>工厂方法模式将对象的实例化推迟到子类</strong>。<br>“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。如果想增加一个产品，只要扩展一个工厂类就可以。<br>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度。<br>工厂方法模式只考虑生产同等级的产品（比如不同牌子的电视机）。不能生产多等级产品（比如电视机和空调）。抽象工厂模式可以解决。</p>
<p><strong>抽象工厂模式</strong><br>一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。<br>工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<h3 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3 单例模式"></a>3 单例模式</h3><p>一个类只有一个实例，且该类能自行创建这个实例的一种模式。<br>单例类只有一个实例对象；该单例对象必须由单例类自行创建；对外提供一个访问该单例的全局访问点。<br><a target="_blank" rel="noopener" href="https://cool-jun.github.io/2022/03/20/singleton/">单例模式</a></p>
<h3 id="4-代理模式"><a href="#4-代理模式" class="headerlink" title="4 代理模式"></a>4 代理模式</h3><p>给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>优点：<br>代理对象可以扩展目标对象的功能；<br>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性；</p>
<p>缺点：<br>代理模式会造成系统设计中类的数量增加；<br>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</p>
<h3 id="5-适配器模式"><a href="#5-适配器模式" class="headerlink" title="5 适配器模式"></a>5 适配器模式</h3><p>作为两个不兼容的接口之间的桥梁。例如：读卡器是作为内存卡和笔记本之间的适配器。</p>
<h3 id="6-装饰器模式"><a href="#6-装饰器模式" class="headerlink" title="6 装饰器模式"></a>6 装饰器模式</h3><p>在不改变现有对象结构的情况下，动态地给该对象增加一些职责。</p>
<img src="/2021/12/27/12-27-desgin-mode/decorator.png" class="">

<h3 id="6-模板模式"><a href="#6-模板模式" class="headerlink" title="6 模板模式"></a>6 模板模式</h3><p>一个抽象类公开定义了执行它的方法的方式（模板）。它的子类可以按照需要重写方法实现，但调用将以抽象类中定义的方式进行。</p>
<p>它封装了不变部分，扩展了可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。<br>它在父类中提取了公共部分代码，便于代码复用。</p>
<h3 id="7-观察者模式"><a href="#7-观察者模式" class="headerlink" title="7 观察者模式"></a>7 观察者模式</h3><p>指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并且被自动更新。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/23/12-23-Mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="He Jun">
      <meta itemprop="description" content="Like Sunday，Like Rain">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cool-jun的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/23/12-23-Mysql/" class="post-title-link" itemprop="url">mysql</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-23 10:28:25" itemprop="dateCreated datePublished" datetime="2021-12-23T10:28:25+08:00">2021-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-22 20:56:16" itemprop="dateModified" datetime="2022-04-22T20:56:16+08:00">2022-04-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/12/23/12-23-Mysql/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/12/23/12-23-Mysql/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-事务的特性"><a href="#1-事务的特性" class="headerlink" title="1 事务的特性"></a>1 事务的特性</h3><p><strong>原子性（Atomicity）</strong><br>原子性指事务是一个不可分割的工作单元，事务中的操作要么全部成功，要么全部失败。<br>如果事务中的一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。</p>
<p>MySQL日志：二进制日志（bin log）、错误日志（error log）、慢查询日志（slow query log）、一般查询日志（general log），InnoDB存储引擎还提供了两种事务日志，重做日志（redo log）和回滚日志（undo log）。</p>
<p>原子性实现原理：undo log。<br>实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。InnoDB实现回滚，靠的是undo log。<br>当事务对数据库进行修改时，InnoDB会生成对应的undo log。如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。undo log属于逻辑日志，它记录的是相关sql执行的信息。</p>
<p><strong>一致性（Consistency）</strong><br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。<br>张三向李四转100元，转账前和转账后的数据是正确的状态，这就叫一致性，如果出现张三转出100元，李四账号没有增加100元这就出现了数据错误，就没有达到一致性。</p>
<p><strong>隔离性（Isolation）</strong><br>隔离性指多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的数据操作所干扰，多个并发事务之间要相互隔离。<br>锁机制保证隔离性。<br>事务在修改数据之前，需要先获得相应的锁。获得锁之后，事务便可以修改数据。在该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务释放锁。</p>
<p><strong>持久性（Durability）</strong><br>持久性指一个事务一旦被提交，它对数据库中数据的改变就是永久性的。<br>持久性实现原理：redo log。</p>
<p>InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲。<br>当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool。当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中(这一过程称为刷脏页)。<br>Buffer Pool的使用大大提高了读写数据的效率，但是也带来了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。</p>
<p>引入redo log，当数据修改时，除了修改Buffer Pool中的数据，还会在redo log中记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷新磁盘。<br>如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。<br>redo log采用的是WAL(Write-ahead logging，预写式日志)，所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</p>
<p><strong>redo log vs bin log</strong><br>redo log是用于crash recovery的，保证MySQL宕机也不会影响持久性；bin log是用于point-in-time recovery的，保证服务器可以基于时间点恢复数据，此外bin log还用于主从复制。<br>redo log是InnoDB存储引擎实现的，而bin log是MySQL的服务器层实现的，同时支持InnoDB和其他存储引擎。<br>redo log是物理日志，内容基于磁盘的Page。bin log是逻辑日志，内容是一条条sql。</p>
<h3 id="2-并发事务带来的问题"><a href="#2-并发事务带来的问题" class="headerlink" title="2 并发事务带来的问题"></a>2 并发事务带来的问题</h3><p>在应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作），这会带来一些问题。</p>
<p><strong>脏读</strong><br>一个事务读到另一个事务还没有提交的数据。<br>例如：T1修改一个数据但未提交，T2随后读取这个数据。如果T1撤销了这次修改，那么T2读取的数据是脏数据。<br>这种读取到另一个事务未提交的数据的现象就是脏读(Dirty Read)。</p>
<p><strong>不可重复读</strong><br>一个事务先后读取同一条记录，但两次读取的数据不一样。<br>事务A多次读取同一数据，但事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。<br>出现原因：读取数据的同时可以进行修改。</p>
<p><strong>脏读 vs 不可重复读</strong><br>脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。</p>
<p><strong>幻读</strong><br>在一个事务中多次查询返回的结果集不一样。当一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据。然后事务（T1）再读取时就会发现多了一些原本不存在的数据。</p>
<p>当同一个查询在不同的时间生成不同的行集时，事务中就会出现所谓的幻象问题。例如，如果一个SELECT执行了两次，但第二次返回了第一次未返回的行，则该行是“幻影”行。</p>
<p><strong>不可重复读 vs 幻读</strong><br>不可重复读：同一条记录（一条数据）的内容被其他事物修改了，关注的是update、delete操作一条数据的情况。<br>幻读：查询某个范围（多条数据）的数据行变多或变少了，在于insert、delete操作。</p>
<h3 id="2-事务隔离级别"><a href="#2-事务隔离级别" class="headerlink" title="2 事务隔离级别"></a>2 事务隔离级别</h3><p>READ_UNCOMMITTED（读未提交）<br>允许读取还没有被提交的数据变更，所以很明显这个级别的隔离机制会产生脏读、不可重复读、幻读问题。</p>
<p>READ_COMMITED（读已提交）（Oracle默认隔离级别）<br>允许读取并发事务已经提交的数据，自然能够防止脏读，但是会出现不可重复读和幻读。</p>
<p>REPEATABLE_READ（可重复读）（Mysql默认隔离级别）<br>对同一字段的多次读取结果都是一致的，除非数据被事务本身所修改，可以防止脏读和不可重复读，但幻读仍有可能发生。</p>
<p>SERLALIZABLE（串行化）<br>最高的事务隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，解决了脏读、不可重复读和幻读问题。</p>
<ul>
<li>事务隔离级别为读已提交时，写数据只会锁住相应的行。</li>
<li>事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。</li>
<li>事务隔离级别为串行化时，读写数据都会锁住整张表。</li>
<li>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。</li>
</ul>
<h4 id="在SQL标准中，RR是无法避免幻读问题的，但是InnoDB实现的RR避免了幻读问题。"><a href="#在SQL标准中，RR是无法避免幻读问题的，但是InnoDB实现的RR避免了幻读问题。" class="headerlink" title="在SQL标准中，RR是无法避免幻读问题的，但是InnoDB实现的RR避免了幻读问题。"></a>在SQL标准中，RR是无法避免幻读问题的，但是InnoDB实现的RR避免了幻读问题。</h4><p>MVCC的特点就是在同一时刻，不同事务可以读取到不同版本的数据，从而可以解决脏读和不可重复读的问题。<br>MVCC实际上就是通过数据的隐藏列和回滚日志（undo log），实现多个版本数据的共存。这样的好处是，使用MVCC进行读数据的时候，不用加锁，从而避免了同时读写的冲突。</p>
<p>在实现MVCC时，每一行的数据中会额外保存几个隐藏的列，比如当前行创建时的版本号、删除时间和指向undo log的回滚指针。这里的版本号并不是实际的时间值，而是系统版本号。每当开始新的事务，系统版本号都会自动递增。事务开始时的系统版本号会作为事务的版本号，用来与查询每行记录的版本号进行比较。</p>
<p>每个事务又有自己的版本号，这样在事务中执行数据操作时，就通过版本号的比较来达到数据版本控制的目的。<br>另外，InnoDB实现的隔离级别RR是可以避免幻读现象的，这是通过next-key lock机制实现的。<br>next-key lock实际上就是行锁的一种，只不过它不只是会锁住当前行记录的本身，还会锁定一个范围。</p>
<h3 id="3-mysql架构"><a href="#3-mysql架构" class="headerlink" title="3 mysql架构"></a>3 mysql架构</h3><img src="/2021/12/23/12-23-Mysql/mysql.png" class="">
<p>MySQL可以分为Server层和存储引擎两部分。</p>
<p>Server层包括：连接器、查询缓存、分析器、优化器、执行器等，涵盖了MySQL大多数核心服务功能，以及所有的内置函数（如：日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，例如：存储过程、触发器、视图等等。</p>
<p>存储引擎：负责数据的存储和提取。其架构是插件式的，支持InnoDB、MyISAM等多个存储引擎。默认是InnoDB，但是在建表时可以通过engine = xxx来指定存储引擎。不同存储引擎的数据表存取方式不同，支持的功能也不同。</p>
<h3 id="4-一条sql语句的执行过程"><a href="#4-一条sql语句的执行过程" class="headerlink" title="4 一条sql语句的执行过程"></a>4 一条sql语句的执行过程</h3><ol>
<li>连接数据库。</li>
<li>查询缓存。MySQL拿到一个查询请求后，会先到查询缓存查找，看之前是不是执行过这条语句。因为执行过的语句及其结果都会以key-value的形式，被直接缓存到内存中。其中，key是查询语句，value是查询结果。如果你的查询能够直接在缓存中找到（key），那么这个value就会直接返回给客户端。如果语句不在查询缓存中，就会继续后面的执行阶段。但是大多数情况下不建议使用查询缓存。MySQL8.0版本已经将查询缓存功能删除了。</li>
<li>分析器。进行sql语句的词法分析、语法分析。</li>
<li>优化器。优化器的作用就是以它认为的最优执行方案去执行。例如：在表里有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</li>
<li>执行器。执行语句，然后从存储引擎返回数据。</li>
</ol>
<h3 id="5-MyISAM与InnoDB"><a href="#5-MyISAM与InnoDB" class="headerlink" title="5 MyISAM与InnoDB"></a>5 MyISAM与InnoDB</h3><p>MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB，并且5.5版本后默认的存储引擎为InnoDB。</p>
<p>MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB类型更快，但是不提供事务支持。InnoDB提供事务支持，外键等高级数据库功能。具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p>
<p>MyISAM不支持事务，InnoDB支持事务。<br>MyISAM不支持外键，InnoDB支持外键。<br>MyISAM只支持表级锁(table-level locking)，而InnoDB支持行级锁(rowlevel locking)和表级锁，默认为行级锁。</p>
<p>仅InnoDB支持mvcc。应对高并发事务，MVCC比单纯的加锁更高效;<br>MVCC只在READ COMMITTED和REPEATABLE READ两个隔离级别下工作;<br>MVCC可以使用乐观(optimistic)锁和悲观(pessimistic)锁来实现。</p>
<h3 id="6-mvcc（Mutil-Version-Concurrency-Control-多版本并发控制"><a href="#6-mvcc（Mutil-Version-Concurrency-Control-多版本并发控制" class="headerlink" title="6 mvcc（Mutil-Version Concurrency Control)多版本并发控制"></a>6 mvcc（Mutil-Version Concurrency Control)多版本并发控制</h3><p>MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。<br>早期的数据库系统，只有读-读之间可以并发，读-写，写-写都要阻塞。引入多版本之后，只有写-写之间相互阻塞，其他2种操作都可以并行，这样大幅度提高了数据库的并发性能。</p>
<p>原理就是通过数据行的多个版本管理来实现数据库的并发控制，简单来说就是保存数据的历史版本，可以通过比较版本号决定数据是否显示出来。<br>InnoDB是在undo log中实现的，通过undo log可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。</p>
<h3 id="7-MySQL行锁与表锁"><a href="#7-MySQL行锁与表锁" class="headerlink" title="7 MySQL行锁与表锁"></a>7 MySQL行锁与表锁</h3><p>MyISAM只支持表锁，InnoDB支持表锁和行锁，默认为行锁。</p>
<p>表级锁：Mysql中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和InnoDB都支持表级锁。</p>
<p>行级锁：Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。<br>InnoDB支持行级锁，包括如下几种：</p>
<ul>
<li>Record Lock: 对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项。</li>
<li>Gap Lock: 对索引项之间的“间隙”加锁，锁定记录的范围，不包含索引项本身。其他事务不能在锁范围内插入数据。</li>
<li>Next-key Lock：锁定索引项本身和索引范围，即Record Lock和Gap Lock的结合，可解决幻读问题。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="He Jun"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">He Jun</p>
  <div class="site-description" itemprop="description">Like Sunday，Like Rain</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">91</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/cool-jun" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cool-jun" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:15697404219@163.com" title="E-Mail → mailto:15697404219@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async="async"></script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">He Jun</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'yC6HMe8HT9vQsskxW96mK1nE-gzGzoHsz',
      appKey     : 'k5q8VxTAtwXdTUJ0eRFXyESY',
      placeholder: "老铁，不想说2句吗？",
      avatar     : 'wavatar',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
