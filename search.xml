<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>binary_search</title>
    <url>/2021/09/19/binary-search/</url>
    <content><![CDATA[<h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704 二分查找"></a>704 二分查找</h3><p>给定一个n个元素有序的（升序）整型数组nums和一个目标值target，写一个函数搜索nums中的target，如果目标值存在返回下标，否则返回-1。<br>tips<br>你可以假设 nums 中的所有元素是不重复的。<br>n 将在 [1, 10000]之间。<br>nums 的每个元素都将在[-9999, 9999]之间。</p>
<p><strong>代码</strong><br>思路：有序整型数组查找给定的target，标准的二分查找。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int search(int[] nums, int target) &#123;</span><br><span class="line">        int low &#x3D; 0, high &#x3D; nums.length - 1;</span><br><span class="line">        while (low &lt;&#x3D; high) &#123;</span><br><span class="line">            int middle &#x3D; (low + high) &#x2F; 2;</span><br><span class="line">            if (target &#x3D;&#x3D; nums[middle]) &#123;</span><br><span class="line">                return middle;</span><br><span class="line">            &#125; else if (target &lt; nums[middle]) &#123;</span><br><span class="line">                high &#x3D; middle - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                low &#x3D; middle + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>减少内存消耗</strong><br>变量只有在用到它的时候才定义和实例化<br>尽量避免使用static变量，类里面私有常量可以用final来代替<br>StringBuffer代替String进行字符串相加</p>
<p><strong>小知识</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(8 &gt;&gt; 1);  &#x2F;&#x2F;4  右移1位相当于除以2</span><br><span class="line">System.out.println(32 &gt;&gt; 3); &#x2F;&#x2F; 4 右移3位相当于除以2^3</span><br><span class="line">System.out.println(8 &lt;&lt; 1);  &#x2F;&#x2F;16 左移1位相当于乘以2</span><br><span class="line">System.out.println(2 &lt;&lt; 3);  &#x2F;&#x2F;16 左移3位相当于乘以2^3</span><br></pre></td></tr></table></figure>


<h3 id="278-First-Bad-Version"><a href="#278-First-Bad-Version" class="headerlink" title="278 First Bad Version"></a>278 First Bad Version</h3><p>寻找左侧边界的二分查找<br>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<p>tips<br>1 &lt;= bad &lt;= n &lt;= 2^31 - 1</p>
<p><strong>代码</strong><br>思路：因为每个版本都是基于之前的版本开发的，所以正确的版本之前的版本都是正确的，错误的版本之后的版本都是错误的。因此需要找到正确和错误版本的临界点，可以采用二分查找法，每查找一次都可以缩小范围（左边界或右边界），效率高。<br>实现一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 二分搜索的演化版本</span><br><span class="line">    public int firstBadVersion(int n) &#123;</span><br><span class="line">        int low &#x3D; 1, high &#x3D; n;</span><br><span class="line">        &#x2F;&#x2F; 终止条件是low &#x3D;&#x3D; high</span><br><span class="line">        while (low &lt; high) &#123;</span><br><span class="line">            &#x2F;&#x2F; 防止溢出超时,low和high相加超过int表示的最大范围时就会溢出变为负数</span><br><span class="line">            &#x2F;&#x2F; int middle &#x3D; (low + high) &#x2F; 2;</span><br><span class="line">            int middle &#x3D; low + (high - low) &#x2F; 2;</span><br><span class="line">            &#x2F;&#x2F; 错误的版本</span><br><span class="line">            if (isBadVersion(middle)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 可能这就是第一个错误的版本</span><br><span class="line">                high &#x3D; middle;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                low &#x3D; middle + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实现二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int low &#x3D; 1, high &#x3D; n;</span><br><span class="line">        int firstBadVersion &#x3D; n;  &#x2F;&#x2F; 假设n为第一个错误版本</span><br><span class="line">        while (low &lt;&#x3D; high) &#123;</span><br><span class="line">            int middle &#x3D; low + (high - low) &gt;&gt; 1;  &#x2F;&#x2F; 防止溢出</span><br><span class="line">            if (isBadVersion(middle)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 错误版本，可能是第一个，也可能不是。继续往左边搜索，同时记录下错误版本位置</span><br><span class="line">                high &#x3D; middle - 1;</span><br><span class="line">                firstBadVersion &#x3D; middle;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 不是错误版本，往右边搜索</span><br><span class="line">                low &#x3D; middle + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return firstBadVersion;</span><br></pre></td></tr></table></figure>

<h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35 搜索插入位置"></a>35 搜索插入位置</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>请必须使用时间复杂度为 O(log n) 的算法。</p>
<p>tips<br>1 &lt;= nums.length &lt;= 10^4<br>-10^4 &lt;= nums[i] &lt;= 10^4<br>nums 为无重复元素的升序排列数组<br>-10^4 &lt;= target &lt;= 10^4</p>
<p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">        int low &#x3D; 0, high &#x3D; nums.length - 1;</span><br><span class="line">        while (low &lt;&#x3D; high) &#123;</span><br><span class="line">            int middle &#x3D; low + (high - low) &#x2F; 2;</span><br><span class="line">            if (target &#x3D;&#x3D; nums[middle]) &#123;</span><br><span class="line">                return middle;</span><br><span class="line">            &#125; else if (target &gt; nums[middle]) &#123;</span><br><span class="line">                low &#x3D; middle + 1;</span><br><span class="line">            &#125; else if (target &lt; nums[middle]) &#123;</span><br><span class="line">                high &#x3D; middle - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return low;  &#x2F;&#x2F; 目标值未找到，返回应插入的位置</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分查找法详解"><a href="#二分查找法详解" class="headerlink" title="二分查找法详解"></a>二分查找法详解</h3><h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><p><strong>循环结束条件</strong><br>while（low&lt;=high）还是while（low&lt;high);<br>low&lt;=high意味着循环终止条件为low=high+1;<br>low&lt;high意味着循环终止条件为low==high,具体问题具体分析。</p>
<p><strong>middle值</strong><br>low=middle or low=middle+1 or high=middle or high=middle-1 and so on</p>
<p><strong>防止溢出</strong><br>初始化时middle=low+(high-low)/2</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>bitmap</title>
    <url>/2020/11/16/bitmap/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在一个结构中，用一个比特位来描述一个数据的状态，这种结构就称为位图。0表示数据不存在，1表示数据存在。位图实际上是哈希表的一种变形。<br>在数据存储方面，位图的应用非常广泛。比如说现在要存储20亿个不重复的数据，int类型为4个字节，就需要80亿个字节来存储。1GB的内存表示的是10亿个字节，此时就需要8GB的内存来存放这些数据，而我们普通的电脑内存一般都是4G的内存，这显然是存放不下的。但是如果能用一个比特位来存放一个整型数据，则只需要0.5GB的内存。这大大节省了内存空间。</p>
<h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
<th>运算规则</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>与</td>
<td>都为1时结果才为1</td>
</tr>
<tr>
<td></td>
<td>或</td>
<td>都为0时结果才为0</td>
</tr>
<tr>
<td>^</td>
<td>异或</td>
<td>相同为0，相异为1</td>
</tr>
<tr>
<td>~</td>
<td>取反</td>
<td>0变1，1变0</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>左移若干位，高位丢弃，低位补0</td>
</tr>
<tr>
<td></td>
<td>右移</td>
<td>右移若干位，无符号数，高位补0；有符号数，有的补符号位（算术右移），有的补0（逻辑右移）</td>
</tr>
</tbody></table>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>内存不能以比特位为单位进行申请，所以这里以32位（4字节）为一个数组元素长度进行内存的申请。<br>位图的基本操作有初始化；设置某位为1或0（将数据存入位图或移除）；验证某位是1还是0（验证数据存不存在位图中）等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指定位图最大能表示的数字</span><br><span class="line">#define MAXSIZE 1000</span><br><span class="line"></span><br><span class="line">struct BitMap</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t *data; &#x2F;&#x2F;位图以uint32_t为单位申请内存</span><br><span class="line">	uint32_t capacity; &#x2F;&#x2F;位图中最大能表示的bit个数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 位图初始化</span><br><span class="line">*&#x2F;</span><br><span class="line">void BitMapInit(struct BitMap *bm, uint32_t capacity)</span><br><span class="line">&#123;</span><br><span class="line">	if (bm &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bm-&gt;capacity &#x3D; capacity;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;需要申请多少个32bit内存</span><br><span class="line">	uint32_t size &#x3D; bm-&gt;capacity &#x2F; (sizeof(uint32_t)*8) + 1;</span><br><span class="line"></span><br><span class="line">	bm-&gt;data &#x3D; (uint32_t *)malloc(size * sizeof(uint32_t));</span><br><span class="line"></span><br><span class="line">	memset(bm-&gt;data, 0, size * sizeof(uint32_t));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 获取指定位所在的数组下标及偏移量</span><br><span class="line">*&#x2F;</span><br><span class="line">void GetIndexAndOffset(uint32_t x, uint32_t *index, uint32_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;计算该位在哪个数组元素内（数组元素以32位为一个单元）</span><br><span class="line">    *index &#x3D; x &#x2F; (sizeof(uint32_t)*8);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;offset表示x在下标为index的数组元素的哪一位（从0开始计算）</span><br><span class="line">    *offset &#x3D; x % (sizeof(uint32_t)*8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 设置某位为1</span><br><span class="line">*&#x2F;</span><br><span class="line">void BitMapSetOne(BitMap *bm, uint32_t x)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t index &#x3D; 0, offset &#x3D; 0;</span><br><span class="line">	GetIndexAndOffset(x, &amp;index, &amp;offset);</span><br><span class="line"></span><br><span class="line">    if (bm &#x3D;&#x3D; NULL || index &gt;&#x3D; bm-&gt;capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置data[index]的第offset位为1，其余不变。</span><br><span class="line">    bm-&gt;data[index] &#x3D; bm-&gt;data[index] | (0x1 &lt;&lt; offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 设置某位为0</span><br><span class="line">*&#x2F;</span><br><span class="line">void BitMapSetZero(BitMap *bm, uint32_t x)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t index &#x3D; 0, offset &#x3D; 0;</span><br><span class="line">	GetIndexAndOffset(x, &amp;index, &amp;offset);</span><br><span class="line"></span><br><span class="line">    if (bm &#x3D;&#x3D; NULL || index &gt;&#x3D; bm-&gt;capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置data[index]的第offset位为0，其余不变。</span><br><span class="line">    bm-&gt;data[index] &#x3D; bm-&gt;data[index] &amp; ~(0x1 &lt;&lt; offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 设置位图的所有位为1</span><br><span class="line">*&#x2F;</span><br><span class="line">void BitMapFill(BitMap *bm)</span><br><span class="line">&#123;</span><br><span class="line">    if (bm &#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;计算位图中共有多少32bit的内存单元</span><br><span class="line">    uint32_t size &#x3D; bm-&gt;capacity &#x2F; (sizeof(uint32_t)*8) + 1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;按字节将所有的比特位均置为0</span><br><span class="line">    memset(bm-&gt;data, 0xff, size * sizeof(uint32_t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 设置位图的所有位为0</span><br><span class="line">*&#x2F;</span><br><span class="line">void BitMapClean(BitMap *bm)</span><br><span class="line">&#123;</span><br><span class="line">    if (bm &#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;计算位图中共有多少32bit的内存单元</span><br><span class="line">    uint32_t size &#x3D; bm-&gt;capacity &#x2F; (sizeof(uint32_t)*8) + 1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;按字节将所有的比特位均置为0</span><br><span class="line">    memset(bm-&gt;data, 0x0, size * sizeof(uint32_t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 测试某位是否为1</span><br><span class="line">*&#x2F;</span><br><span class="line">int BitMapTest(BitMap *bm, uint32_t x)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t index &#x3D; 0, offset &#x3D; 0;</span><br><span class="line">	GetIndexAndOffset(x, &amp;index, &amp;offset);</span><br><span class="line"></span><br><span class="line">    if (bm &#x3D;&#x3D; NULL || index &gt;&#x3D; bm-&gt;capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;用1与之按位与，如果结果为0，则该位为0，否则为1</span><br><span class="line">    &#x2F;&#x2F;如果该位为1时，按位与完的结果必定只有该位为1，其余位为0，所以对结果进行判断时</span><br><span class="line">    &#x2F;&#x2F;只能跟0进行比较，不能跟1进行比较</span><br><span class="line">    uint32_t ret &#x3D; bm-&gt;data[index] &amp; (0x1 &lt;&lt; offset);</span><br><span class="line"></span><br><span class="line">    if (ret &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else</span><br><span class="line">    &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 销毁位图</span><br><span class="line">*&#x2F;</span><br><span class="line">void BitMapDestroy(BitMap *bm)</span><br><span class="line">&#123;</span><br><span class="line">    if (bm &#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(bm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 输入</span><br><span class="line">*&#x2F;</span><br><span class="line">void InputStandard()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;请选择操作：&quot; &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; &quot;*******************************&quot; &lt;&lt; std::endl; </span><br><span class="line">	std::cout &lt;&lt; &quot;0、退出程序&quot; &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; &quot;1、设置某位为1(1-1000)&quot; &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; &quot;2、设置某位为0(1-1000)&quot; &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; &quot;3、设置所有位为1(1-1000)&quot; &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; &quot;4、设置所有位为0(1-1000)&quot; &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; &quot;5、测试某位是否为1(1-1000)&quot; &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; &quot;*******************************&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int x, flag;</span><br><span class="line">	BitMap *bm &#x3D; (BitMap *)malloc(sizeof(BitMap));</span><br><span class="line">	BitMapInit(bm, MAXSIZE);</span><br><span class="line">	</span><br><span class="line">	InputStandard();</span><br><span class="line">	std::cin &gt;&gt; flag;</span><br><span class="line">	</span><br><span class="line">	while (flag !&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		switch(flag)</span><br><span class="line">		&#123;</span><br><span class="line">			case 0:</span><br><span class="line">				exit(0);</span><br><span class="line">				break;</span><br><span class="line">			case 1:</span><br><span class="line">				std::cin &gt;&gt; x;</span><br><span class="line">				BitMapSetOne(bm, x);</span><br><span class="line">				break;</span><br><span class="line">			case 2:</span><br><span class="line">				std::cin &gt;&gt; x;</span><br><span class="line">				BitMapSetZero(bm, x);</span><br><span class="line">				break;</span><br><span class="line">			case 3:</span><br><span class="line">				BitMapFill(bm);</span><br><span class="line">				break;</span><br><span class="line">			case 4:</span><br><span class="line">				BitMapClean(bm);</span><br><span class="line">				break;</span><br><span class="line">			case 5:</span><br><span class="line">				std::cin &gt;&gt; x;</span><br><span class="line">			    if (BitMapTest(bm, x) &#x3D;&#x3D; 1)</span><br><span class="line">			    &#123;</span><br><span class="line">			    	std::cout &lt;&lt; x &lt;&lt; &quot;存在位图中！&quot; &lt;&lt; std::endl;</span><br><span class="line">				&#125; else</span><br><span class="line">				&#123;</span><br><span class="line">					std::cout &lt;&lt; x &lt;&lt; &quot;不存在位图中！&quot; &lt;&lt; std::endl;</span><br><span class="line">				&#125;</span><br><span class="line">				break;</span><br><span class="line">			default:</span><br><span class="line">			    std::cout &lt;&lt; &quot;请输入正确的操作序号！&quot; &lt;&lt; std::endl; </span><br><span class="line">			    break;</span><br><span class="line">		&#125;</span><br><span class="line">		InputStandard();</span><br><span class="line">		std::cin &gt;&gt; flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用小技巧"><a href="#常用小技巧" class="headerlink" title="常用小技巧"></a>常用小技巧</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 判断奇偶</span><br><span class="line">* 根据最未位是0还是1来决定，0就是偶数，1就是奇数。</span><br><span class="line">* 因此可以用if (a &amp; 1 &#x3D;&#x3D; 0)代替if (a % 2 &#x3D;&#x3D; 0)来判断a是不是偶数。</span><br><span class="line">*&#x2F;</span><br><span class="line">void IsOddOrEven(int number)</span><br><span class="line">&#123;</span><br><span class="line">	if ((number &amp; 1) &#x3D;&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; number &lt;&lt; &quot; is an even number!&quot; &lt;&lt; std::endl;</span><br><span class="line">	&#125; else</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; number &lt;&lt; &quot; is an odd number!&quot; &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 交换两数</span><br><span class="line">*&#x2F;</span><br><span class="line">void Swap(int &amp;a, int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	if (a !&#x3D; b)</span><br><span class="line">	&#123;</span><br><span class="line">		a ^&#x3D; b;</span><br><span class="line">		b ^&#x3D; a;</span><br><span class="line">		a ^&#x3D; b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 变换符号</span><br><span class="line">* 二进制只需要取反后加1即可</span><br><span class="line">*&#x2F;</span><br><span class="line">int SignReversal(int a)</span><br><span class="line">&#123;</span><br><span class="line">	return ~a + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 取绝对值</span><br><span class="line">*&#x2F;</span><br><span class="line">int Abs(int a)</span><br><span class="line">&#123;</span><br><span class="line">	int i &#x3D; a &gt;&gt; 31;</span><br><span class="line">&#x2F;&#x2F;	return i &#x3D;&#x3D; 0 ? a : (~a + 1);</span><br><span class="line">	return ((a ^ i) - i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	IsOddOrEven(1);</span><br><span class="line">	IsOddOrEven(2);</span><br><span class="line"></span><br><span class="line">	int a &#x3D; 3, b &#x3D; 4;</span><br><span class="line">	Swap(a, b);</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; &quot; : &quot; &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; SignReversal(10) &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; SignReversal(-8) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; Abs(-2) &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; Abs(6) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/11/16/bitmap/bitmap.jpg" class="">

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>给定100亿个整数，设计算法找到只出现一次的整数。</strong><br>100亿个整数采用位图存储的话需要1.5G的内存，并且如果需要记录出现次数的话一个比特位是无法做到的，我们需要2个比特位那么就需要2.5G的内存，如果我们系统的内存不足够的话，我们需要将100亿个数据分成1000份文件，将每个文件的数据通过位图存储，我们采用两个比特位00：没有出现，01，出现一次，10出现多次，11舍弃，再将这1000个文件中出现一次的数据，统计到一个文件里。<br><strong>给两个文件，分别有100亿个整数，我们只有1G内存，如何找到两个文件交集。</strong><br>将第一个文件的数据分成1000份存储到位图里，再判断第二份文件中的数据是否在位图中。<br><strong>1个文件有100亿个int，1G内存，设计算法找到出现次数不超过2次的所有整数。</strong><br>我们需要将100亿个数据分成1000份文件，将每个文件的数据通过位图存储，我们采用两个比特位00：没有出现，01，出现一次，10出现2次，11舍弃，再将这1000个文件中出现不超过两次次的数据。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>位图</tag>
      </tags>
  </entry>
  <entry>
    <title>Three ways to create Java Multithread</title>
    <url>/2020/09/23/concurrency/</url>
    <content><![CDATA[<p>最近回顾了一下Java的知识，发现创建Java多线程的方式一般有三种。下面将一一讲诉。</p>
<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><p>通过继承Thread类，重写run方法可以实现多线程。但由于Java单继承的特点，意味着继承Thread类的类不能再继承其它类了，这也是一个缺点吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyThread1 extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;启动5个线程，分别执行run方法。</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new MyThread1().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><p>通过实现Runnable接口的run方法来实现多线程，启动线程需要通过Thread类。一般情况下通过此方法来创建多线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyThread2 implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            new Thread(new MyThread2()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p>通过实现Callable接口的call方法来实现多线程，有返回值。可以通过FutureTask包装器来创建Thread线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyThread3&lt;V&gt; implements Callable&lt;V&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public V call() throws Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;通过MyThread3实例化一个callable对象</span><br><span class="line">            Callable&lt;Integer&gt; callable &#x3D; new MyThread3&lt;&gt;();</span><br><span class="line">            &#x2F;&#x2F;通过callable实例化FutureTask类</span><br><span class="line">            FutureTask&lt;Integer&gt; task &#x3D; new FutureTask&lt;&gt;(callable);</span><br><span class="line">            new Thread(task).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>copy constructor</title>
    <url>/2021/04/04/copy/</url>
    <content><![CDATA[<h3 id="浅拷贝简介"><a href="#浅拷贝简介" class="headerlink" title="浅拷贝简介"></a>浅拷贝简介</h3><p>浅拷贝会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本数据类型，拷贝的就是值；如果属性是引用数据类型，拷贝的就是内存地址。<br>基本数据类型是值传递，所以修改一个对象的值不会影响另一个对象。<br>引用数据类型是引用传递，浅拷贝只是把内存地址赋值给了新对象，它们指向同一内存空间。所以改变其中一个也会影响另一个。</p>
<h3 id="浅拷贝实现"><a href="#浅拷贝实现" class="headerlink" title="浅拷贝实现"></a>浅拷贝实现</h3><p>类需要实现Cloneable接口，并重写clone()方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Subject &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Subject(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;[Shallow Copy: &quot; + this.hashCode() + &quot;,name: &quot; + name + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student implements Cloneable &#123;</span><br><span class="line">    &#x2F;&#x2F;引用数据类型</span><br><span class="line">    private Subject subject;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;基本数据类型</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Subject getSubject() &#123;</span><br><span class="line">        return subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSubject(Subject subject) &#123;</span><br><span class="line">        this.subject &#x3D; subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 重写clone()方法</span><br><span class="line">     * @return Object</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() &#123;</span><br><span class="line">        &#x2F;&#x2F;浅拷贝</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;直接调用父类的clone()方法</span><br><span class="line">            return super.clone();</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;[Student: &quot; + this.hashCode() + &quot;,subject:&quot; + subject + &quot;,name:&quot; + name + &quot;,age:&quot; + age + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ShallowCopy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Subject subject1 &#x3D; new Subject(&quot;math&quot;);</span><br><span class="line"></span><br><span class="line">        Student student1 &#x3D; new Student();</span><br><span class="line">        student1.setSubject(subject1);</span><br><span class="line">        student1.setName(&quot;hj&quot;);</span><br><span class="line">        student1.setAge(22);</span><br><span class="line">        System.out.println(student1.toString());</span><br><span class="line"></span><br><span class="line">        Student student2 &#x3D; (Student) student1.clone();</span><br><span class="line">        System.out.println(student2.toString());</span><br><span class="line"></span><br><span class="line">        student2.setName(&quot;cjm&quot;);</span><br><span class="line">        student2.setAge(23);</span><br><span class="line">        System.out.println(student1.toString());</span><br><span class="line">        System.out.println(student2.toString());</span><br><span class="line"></span><br><span class="line">        Subject subject2 &#x3D; student2.getSubject();</span><br><span class="line">        subject2.setName(&quot;hyh&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;student1: &quot; + student1.toString());</span><br><span class="line">        System.out.println(&quot;student2: &quot; + student2.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Student: 1555009629,subject:[Shallow Copy: 41359092,name: math],name:hj,age:22]</span><br><span class="line">[Student: 149928006,subject:[Shallow Copy: 41359092,name: math],name:hj,age:22]</span><br><span class="line">[Student: 1555009629,subject:[Shallow Copy: 41359092,name: math],name:hj,age:22]</span><br><span class="line">[Student: 149928006,subject:[Shallow Copy: 41359092,name: math],name:cjm,age:23]</span><br><span class="line">student1: [Student: 1555009629,subject:[Shallow Copy: 41359092,name: hyh],name:hj,age:22]</span><br><span class="line">student2: [Student: 149928006,subject:[Shallow Copy: 41359092,name: hyh],name:cjm,age:23]</span><br></pre></td></tr></table></figure>
<p>结果中可以看出，通过student1.clone()拷贝对象后得到的student2和student1是两个不同的对象。student1和student2的基本数据类型修改互不影响，而引用数据类型subject的修改则受影响。</p>
<h3 id="深拷贝简介"><a href="#深拷贝简介" class="headerlink" title="深拷贝简介"></a>深拷贝简介</h3><p>深拷贝在拷贝引用数据类型成员变量时，为引用数据类型的成员变量另开辟一个独立的内存空间，实现真正内容上的拷贝。<br>对于引用数据类型，比如数组或者类对象。深拷贝会新建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会影响另一个。<br>对于有多层对象的，每个对象都需要实现Cloneable并重写clone()方法，进而实现对象的串行层层拷贝。</p>
<h3 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h3><p>Student的引用数据类型成员变量Subject需要实现Cloneable接口并重写clone()方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Subject implements Cloneable &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student implements Cloneable &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() &#123;</span><br><span class="line">        &#x2F;&#x2F;深拷贝</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;调用父类的clone()方法</span><br><span class="line">            Student student &#x3D; (Student) super.clone();</span><br><span class="line">            student.subject &#x3D; (Subject) subject.clone();</span><br><span class="line">            return student;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">student1: [Student: 1555009629,subject:[Subject: 41359092,name: math],name:hj,age:22]</span><br><span class="line">student2: [Student: 149928006,subject:[Subject: 713338599,name: hyh],name:cjm,age:23]</span><br></pre></td></tr></table></figure>
<p>结果中可以看出，深拷贝不管是修改基本数据类型还是引用数据类型成员变量时都不会相互影响。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>深浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>diffchain</title>
    <url>/2020/11/16/difftimechain/</url>
    <content><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在差分时间链中，每个表项所包含的计时值并非当前时刻到表项激活时刻的绝对计数，而是该表项先于它的所有表项的计数值之和。<br>例如，在当前时刻，A对象需要等待3个时间单位就应被激活，B对象需要等待5（3+2）个时间单位就应被激活，C对象需要等待10（3+2+5）个时间单位就应被激活。如果有一个等待9个时间单位的对象D需要插入到队列中，由于9-3-2=4，而9-3-2-5=-1，因此D对象需要插入到差分链中介于对象B和对象C之间的位置。<br>系统每接收到一个tick，链首对象的值就减1。当减到0时，链首对象就被激活，并从差分时间链中取下来，下一个对象又成为链首对象。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">	int value;</span><br><span class="line">	struct Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 创建新节点并插入正确位置，返回插入后链表的头指针。</span><br><span class="line">*&#x2F;</span><br><span class="line">struct Node *createNode(struct Node *head, int value)</span><br><span class="line">&#123;</span><br><span class="line">	int temp;</span><br><span class="line">	struct Node *p &#x3D; NULL, *current &#x3D; head, *back &#x3D; NULL;</span><br><span class="line">	p &#x3D; (struct Node *)malloc(sizeof(struct Node));</span><br><span class="line"></span><br><span class="line">	if (head &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		head &#x3D; p;</span><br><span class="line">		p-&gt;value &#x3D; value;</span><br><span class="line">		p-&gt;next &#x3D; NULL;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		back &#x3D; head-&gt;next;</span><br><span class="line">		temp &#x3D; head-&gt;value;</span><br><span class="line"></span><br><span class="line">		if (value &lt;&#x3D; temp) &#123;</span><br><span class="line">			p-&gt;value &#x3D; value;</span><br><span class="line">			p-&gt;next &#x3D; current;</span><br><span class="line">			head &#x3D; p;</span><br><span class="line">		&#125; else if (value &gt; temp &amp;&amp; back &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">			p-&gt;value &#x3D; value - temp;</span><br><span class="line">			p-&gt;next &#x3D; back;</span><br><span class="line">			current-&gt;next &#x3D; p;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			while (value &gt; temp &amp;&amp; back !&#x3D; NULL)</span><br><span class="line">			&#123;</span><br><span class="line">				if ((value-(temp+back-&gt;value)) &lt;&#x3D; 0)</span><br><span class="line">				&#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				temp &#x3D; temp + back-&gt;value;</span><br><span class="line">				current &#x3D; current-&gt;next;</span><br><span class="line">				back &#x3D; back-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			p-&gt;value &#x3D; value - temp;</span><br><span class="line">			p-&gt;next &#x3D; back;</span><br><span class="line">			current-&gt;next &#x3D; p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 系统每接收到一个tick，链首对象的值就减1。</span><br><span class="line">* 当减到0时，链首对象就被激活，并从差分时间链中取下来，下一个对象又成为链首对象。</span><br><span class="line">*&#x2F;</span><br><span class="line">struct Node *handleTick(struct Node *head)</span><br><span class="line">&#123;</span><br><span class="line">	if (head &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	struct Node *p &#x3D; head;</span><br><span class="line">	p-&gt;value &#x3D; p-&gt;value - 1;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;指针head被free以后其地址仍然不变(非NULL),只是该地址对应的内存是垃圾,head成了&quot;野指针&quot;。</span><br><span class="line">	&#x2F;&#x2F;指针head被free或者delete之后,要置为NULL。</span><br><span class="line">	if (p-&gt;value &#x3D;&#x3D; 0 &amp;&amp; p-&gt;next &#x3D;&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		free(head);</span><br><span class="line">		head &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (p-&gt;value &#x3D;&#x3D; 0 &amp;&amp; p-&gt;next !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		head &#x3D; p-&gt;next;</span><br><span class="line">		free(p);</span><br><span class="line">		p &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 遍历输出链表</span><br><span class="line">*&#x2F;</span><br><span class="line">void displayNode(struct Node *head)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;输出：&quot;; </span><br><span class="line"></span><br><span class="line">	while (head !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; head-&gt;value &lt;&lt; &quot; &quot;;</span><br><span class="line">		head &#x3D; head-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int value;</span><br><span class="line">	struct Node *head &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; &quot;请输入节点值（输入0处理一次tick；输入负数终止）&quot; &lt;&lt; std::endl;</span><br><span class="line">	std::cin &gt;&gt; value;</span><br><span class="line"></span><br><span class="line">	while (value &gt;&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		if (value &#x3D;&#x3D; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			head &#x3D; handleTick(head);</span><br><span class="line">			displayNode(head);</span><br><span class="line">			std::cout &lt;&lt; &quot;请输入节点值（输入0处理一次tick；输入负数终止）&quot; &lt;&lt; std::endl;</span><br><span class="line">		    std::cin &gt;&gt; value;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			head &#x3D; createNode(head, value);</span><br><span class="line">		    displayNode(head);</span><br><span class="line">		    std::cout &lt;&lt; &quot;请输入节点值（输入0处理一次tick；输入负数终止）&quot; &lt;&lt; std::endl;</span><br><span class="line">		    std::cin &gt;&gt; value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><img src="/2020/11/16/difftimechain/difftimechain.png" class="">

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>差分时间链</tag>
      </tags>
  </entry>
  <entry>
    <title>double-pointer</title>
    <url>/2021/09/27/double-pointer/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>evening</title>
    <url>/2021/08/25/evening/</url>
    <content><![CDATA[<p>距离上一篇博客发出已经过去三月有余，感觉一直没有时间写博客却又满是时间。日子一天天过去，心中渐渐感觉浪费掉了，科研任务也遇到了瓶颈。最近一段时间心中焦躁，不能平静。已经许久未有这种感觉了，还是要收拾好心情，转变态度。毕竟马上研二了，学弟学妹也都要来了。也不经感叹时光飞逝，犹记得去年彼时的自己。初入北京，初识工大。一年的时光还是有成长的，自己也渐渐知道了what is responsibility？研二，收拾身心再出发，论文，冲冲冲。</p>
<p>农历七月十八</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>郁</tag>
      </tags>
  </entry>
  <entry>
    <title>firstblog</title>
    <url>/2020/09/20/firstblog/</url>
    <content><![CDATA[<pre><code>金秋九月，硕果累累。在这个充满收获的季节，一身戎装的我踏上了求学之路。甲子工大，幸运的我考上了这所学校。梦开始的地方，希望在这里发芽。</code></pre>
<h3 id="启程出发"><a href="#启程出发" class="headerlink" title="启程出发"></a>启程出发</h3><p>收拾戎装，准备出发。第一次体验了磁悬浮与飞机的我不得不感叹中国科技发展之迅速。知识的力量是无穷的，希望我国在芯片领域也能更进一步。</p>
<img src="/2020/09/20/firstblog/plane.jpg" class="">

<h3 id="中蓝公寓"><a href="#中蓝公寓" class="headerlink" title="中蓝公寓"></a>中蓝公寓</h3><p>北京工业大学的研究生基本都住在中蓝公寓，不过中蓝公寓离校内还有一段距离，一般大家都是骑车上课。寝室是四人间，上下铺。厕所和澡堂都是公共的，不过令人疑惑的澡堂周六是不开放的。</p>
<img src="/2020/09/20/firstblog/navigation.jpg" class="">

<p>我所在的公寓是蓝悦园，在宿舍的阳台上放眼望去满是高大而豪华的建筑。其实我更想看的是充满历史又能反应北京特色的胡同儿。期待国庆能去转转。</p>
<img src="/2020/09/20/firstblog/scene.jpg" class="">

<h3 id="校内一角"><a href="#校内一角" class="headerlink" title="校内一角"></a>校内一角</h3><p>在这个举办过奥运会的城市，最不缺的就是运动的气息。工大各色各样的运动场馆似乎都有，其中羽毛球场馆还是08年奥运会羽毛球比赛场地。许多人都说研究生的生活充满了枯燥与压力，或许运动就是最好的良药。确实，我非常赞同这个观点，毕竟身体才是革命的本钱。</p>
<img src="/2020/09/20/firstblog/basketball.jpg" class="">]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>出行</tag>
      </tags>
  </entry>
  <entry>
    <title>spring</title>
    <url>/2021/03/24/hurt/</url>
    <content><![CDATA[<p>立春之后的北京逐渐开始暖和起来，春意盎然，似乎也给每个人的心增添了一份温暖。前几日体验了一回蹦床，这确实是个好东西。欢快的时光也变慢了，给这个快节奏的生活按下了一个暂停键。时间定住了，脑海里增添了一份回忆。可这回忆却不像长江后浪拍前浪，前浪会消亡。相反，它会随着岁月的流逝而变得更加难忘，充实着心里的那一份空落落。新的学期到来，我的生活依旧没有改变。还是宿舍-学校两点一线的生活。这几天帮着老师通知考研复试的同学，又让人想起去年今日的自己。一年的付出确实到了收获的季节。种下一粒种子，便会有可能长出一片森林。</p>
<pre><code>        你已经度过了最困难的阶段，你知道自己要做什么，现在你可以用一生的时间去追寻它。</code></pre>
<p>辛丑牛年农历二月十二</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>java_basic</title>
    <url>/2021/09/11/java-basic/</url>
    <content><![CDATA[<h5 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h5><ul>
<li>面向对象（封装、继承、多态）</li>
<li>平台无关性（java虚拟机）</li>
</ul>
<h5 id="Java主要关键字"><a href="#Java主要关键字" class="headerlink" title="Java主要关键字"></a>Java主要关键字</h5><p>||类别|关键字|||||<br>|:—:|:—:|:—:|<br>|权限|private|protected|public||||<br>|类、方法、修饰符|abstract|class|extends|final|implements|interface|<br>|native|new|static|synchronized|transient|volatile|||</p>
<h5 id="break、continue、return？"><a href="#break、continue、return？" class="headerlink" title="break、continue、return？"></a>break、continue、return？</h5><ul>
<li>break：跳出整个循环，执行循环后面的语句。</li>
<li>continue：跳出当前的这一次循环，继续下一次循环。</li>
<li>return：结束方法执行，用于没有返回值的方法。</li>
<li>return value：返回一个特定值，用于有返回值的方法。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>abstract,final,static,this,super</title>
    <url>/2021/04/07/keyword/</url>
    <content><![CDATA[<h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p><strong>abstract</strong>关键字修饰类和方法。</p>
<p>abstract修饰的类称为抽象类，例如：abstract class xxx{}<br>它可以声明引用但不能创建对象。<br>abstract修饰的方法称为抽象方法，例如：abstract void xxx();<br>它只有声明而没有实现。</p>
<p>注意：含有抽象方法的类一定是抽象类，但抽象类中也可以有具体方法；抽象方法必须要在其子类中实现，除非子类也是抽象类。</p>
<p><strong>abstract关键字不能与final、private或static修饰类放在一起</strong><br>abstract修饰的类必须被继承，修饰的方法应该被重写。<br>final修饰的类、属性和方法不能被改变，因此修饰的方法不能被重写。<br>private只能修饰内部类，修饰的属性和方法只能在类内部调用，重写的方法不能访问被private修饰的方法和属性。<br>static修饰的方法是静态的，可以被类直接调用。但abstract修饰的方法是抽象的，没有实现不能被直接调用，需要通过类继承或接口实现来重写抽象方法方可被调用。</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p><strong>final</strong>关键字是最终的、不可修改的，用来修饰类，方法和属性（或变量）。<br>final修饰的类不能被继承，类中的方法也都被隐式的指定为final。<br>final修饰的方法不能被继承类重写。<br>final修饰的属性(或变量)，其值不能被改变。(即常量)<br>finally是异常处理语句，表示总是执行。<br>finalize()是Object中的方法，在垃圾回收器将要回收对象所占内存之前被调用。</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>static</strong>关键字可以修饰属性、方法、代码块和类。<br>static修饰的类是静态内部类。非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外部类，但是静态内部类却没有。所以静态内部类不能访问外部类的非静态成员（变量和方法）。<br>static修饰成员变量和成员方法，它属于类。一般建议通过类名来调用静态成员。类名.静态变量名、对象.静态方法名()。<br>注意：不能在方法体中定义静态变量。<br>static修饰的代码块叫做静态代码块，经常用来初始化静态变量，在类加载时执行，只执行一次。（静态代码块–》非静态代码块–》构造方法）</p>
<p>一般public、static与final一起用来定义公开静态变量。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><strong>this</strong>关键字表示引用类的当前实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class What &#123;</span><br><span class="line">  void manage() &#123;</span><br><span class="line">  this.report();  &#x2F;&#x2F;调用类What的当前实例的方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  void report() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p><strong>super</strong>关键字表示从子类访问父类的变量和方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">  protected int n;</span><br><span class="line"></span><br><span class="line">  protected print() &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father &#123;</span><br><span class="line">  void show() &#123;</span><br><span class="line">    super.n &#x3D; 10;</span><br><span class="line">    super.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this、super不能用在static方法中<br>this代表对本类对象的引用，指向本类对象；super代表对父类对象的引用，指向父类对象。this和super属于对象范畴，静态方法属于类范畴。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>lonesome</title>
    <url>/2021/09/02/lonesome/</url>
    <content><![CDATA[<h3 id="百年孤独-–-加西亚·马尔克斯"><a href="#百年孤独-–-加西亚·马尔克斯" class="headerlink" title="百年孤独 – 加西亚·马尔克斯"></a>百年孤独 – 加西亚·马尔克斯</h3><ul>
<li><p>无论走到哪里，都应该记住，过去都是假的，回忆是一条没有尽头的路，一切以往的春天都不复存在，就连那最坚韧而又狂乱的爱情归根结底也不过是一种转瞬即逝的现实。</p>
</li>
<li><p>生命中曾经有过的所有灿烂，原来终究，都需要用寂寞来偿还。</p>
</li>
<li><p>生命从来不曾离开过孤独而独立存在。无论是我们出生、我们成长、我们相爱还是我们成功失败，直到最后的最后，孤独犹如影子一样存在于生命一隅。</p>
</li>
<li><p>生命中真正重要的不是你遭遇了什么，而是你记住了哪些事，又是如何铭记的。</p>
</li>
<li><p>我们趋行在人生这个亘古的旅途，在坎坷中奔跑，在挫折里涅盘，忧愁缠满全身，痛苦飘洒一地。我们累，却无从止歇；我们苦，却无法回避。</p>
</li>
<li><p>买下一张永久车票，登上一列永无终点的火车。</p>
</li>
<li><p>一个幸福晚年的秘决不是别的，而是与孤寂签订一个体面的协定。</p>
</li>
<li><p>预感总是倏然来临，灵光一现，好像一种确凿无疑的信念在瞬间萌生却无从捕捉。</p>
</li>
<li><p>所有人都显得很寂寞，用自己的方式想尽办法排遣寂寞，事实上仍是延续自己的寂寞。寂寞是造化对群居者的诅咒，孤独才是寂寞的唯一出口。</p>
</li>
<li><p>他们在二十岁的时候没能结婚，因为他们太年轻，到了八十岁，他们还是没能结婚，因为他们太老。</p>
</li>
<li><p>钟摆能让任何东西飞起来，却无法使自己腾空。</p>
</li>
<li><p>只有用水将心上的雾气淘洗干净，荣光才会照亮最初的梦想。</p>
</li>
<li><p>往日的推心置腹已经一去不返，同谋和交流变成敌意与缄默。</p>
</li>
<li><p>别错过机会，人生比你想象中的要短。</p>
</li>
<li><p>很多人选择了向虚拟现实的魅力屈服，寄情于自我幻想，这纵然不切实际却更能与人安慰。</p>
</li>
<li><p>生未百年，死不孤独。</p>
</li>
<li><p>你那么憎恨那些人，跟他们斗了那么久，最终却变得和他们一样，人世间没有任何理想值得以这样的沉沦作为代价。</p>
</li>
<li><p>一分钟的和好抵得过一辈子的友谊。</p>
</li>
<li><p>原来时间也会失误和出现意外，并因此迸裂，在某个房间里留下永恒的片段。</p>
</li>
<li><p>有的人想睡觉，但不是因为困倦，而是出于对睡觉的怀念。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>One Hundred years of Solitude</tag>
      </tags>
  </entry>
  <entry>
    <title>md5+salt</title>
    <url>/2020/10/10/md5-salt/</url>
    <content><![CDATA[<p>传统的md5算法通过产生一个128位（16字节）的散列值（hash value），用于确保信息的安全性。但随着技术的发展，md5无法防止碰撞（collision）且可以被加以破解。<br>salt的出现可以一定程度上解决这个问题。</p>
<h3 id="md5-salt实现原理"><a href="#md5-salt实现原理" class="headerlink" title="md5+salt实现原理"></a>md5+salt实现原理</h3><p><strong>注册</strong><br>1、用户提供用户名和密码<br>2、系统提供一个salt，salt+密码进行散列生成一个hash<br>3、系统将hash和salt分别存放到数据库中</p>
<p><strong>登录</strong><br>1、用户填写用户名和密码<br>2、系统通过用户名找到对应的hash和salt<br>3、系统将密码和salt进行散列生成new_hash<br>4、比较hash与new_hash，相等则表示密码正确，反之密码错误。</p>
<p><strong>流程图如下</strong></p>
<img src="/2020/10/10/md5-salt/md5.png" class="">

<h4 id="md5-salt"><a href="#md5-salt" class="headerlink" title="md5+salt"></a>md5+salt</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;md5</span><br><span class="line">  Md5Hash md5Hash &#x3D; new Md5Hash(&quot;123456&quot;);</span><br><span class="line">  System.out.println(md5Hash.toHex());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;md5+salt</span><br><span class="line">  Md5Hash md5HashSalt &#x3D; new Md5Hash(&quot;123456&quot;, &quot;x0*7ps&quot;);</span><br><span class="line">  System.out.println(md5HashSalt.toHex());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运行结果</span><br><span class="line">  e10adc3949ba59abbe56e057f20f883e</span><br><span class="line">  5f9dcb70720b6f58a2b219015fad5c30</span><br></pre></td></tr></table></figure>

<h4 id="md5-salt-hash散列"><a href="#md5-salt-hash散列" class="headerlink" title="md5+salt+hash散列"></a>md5+salt+hash散列</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;md5+salt+hash散列</span><br><span class="line">  Md5Hash md5Hash1 &#x3D; new Md5Hash(&quot;123456&quot;, &quot;x0*7ps&quot;, 1024);</span><br><span class="line">  System.out.println(md5Hash1.toHex());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运行结果</span><br><span class="line">  14b9f6ecccb925f15cf92c44ff9326ce</span><br></pre></td></tr></table></figure>

<h3 id="shiro实现md5-salt"><a href="#shiro实现md5-salt" class="headerlink" title="shiro实现md5+salt"></a>shiro实现md5+salt</h3><p><strong>自定义realm</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 自定义realm  md5+salt+hash散列</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CustomMd5Realm extends AuthorizingRealm &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</span><br><span class="line">        &#x2F;&#x2F;获取身份信息</span><br><span class="line">        String principal &#x3D; (String) token.getPrincipal();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;根据用户名查询数据库</span><br><span class="line">        if (&quot;hj&quot;.equals(principal)) &#123;</span><br><span class="line">            &#x2F;&#x2F;参数1：用户名  参数2：md5+salt之后的密码 参数3：注册时的salt  参数4：realm名字</span><br><span class="line">            return new SimpleAuthenticationInfo(principal, &quot;14b9f6ecccb925f15cf92c44ff9326ce&quot;,</span><br><span class="line">                    ByteSource.Util.bytes(&quot;x0*7ps&quot;), this.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试验证</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestCustomMd5Authenticator &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        DefaultSecurityManager defaultSecurityManager &#x3D; new DefaultSecurityManager();</span><br><span class="line"></span><br><span class="line">        CustomMd5Realm realm &#x3D; new CustomMd5Realm();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;realm使用hash凭证匹配器</span><br><span class="line">        HashedCredentialsMatcher credentialsMatcher &#x3D; new HashedCredentialsMatcher();</span><br><span class="line">        &#x2F;&#x2F;设置算法为md5</span><br><span class="line">        credentialsMatcher.setHashAlgorithmName(&quot;md5&quot;);</span><br><span class="line">        &#x2F;&#x2F;设置散列次数为1024</span><br><span class="line">        credentialsMatcher.setHashIterations(1024);</span><br><span class="line"></span><br><span class="line">        realm.setCredentialsMatcher(credentialsMatcher);</span><br><span class="line">        defaultSecurityManager.setRealm(realm);</span><br><span class="line"></span><br><span class="line">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class="line"></span><br><span class="line">        Subject subject &#x3D; SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">        UsernamePasswordToken token &#x3D; new UsernamePasswordToken(&quot;hj&quot;, &quot;123456&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">            System.out.println(&quot;login success&quot;);</span><br><span class="line">        &#125; catch (UnknownAccountException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;username error&quot;);</span><br><span class="line">        &#125; catch (IncorrectCredentialsException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;password error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>memory</title>
    <url>/2021/03/21/memory/</url>
    <content><![CDATA[<p>阴沉的天气夹杂着一丝微雨，糟糕的天气也阻挡不了橘子洲的人来人往。这是我第二次来橘子洲了，一代伟人毛主席的头像依然屹立在橘子洲头，来来往往的游客依旧络绎不绝。每一次来都有不同的感受，但这次却又冥冥之中透露着一种伤感。不知所来，又似一语成谶。不变的永远在，变的确是弹指之间。</p>
<p>漫步在橘间小道，淅淅沥沥的雨点滴在左肩。走着走着树上的鸟窝便吸引了我的注意，那时觉得有点不可思议，因为满树全是人造的鸟窝，但很快就理解了。原来鸟窝里面夹杂着五彩的灯光，为夜间的橘子洲增添一份绚丽。此时的我完全沉浸在幸福愉悦之中，想象不到几天之后的世界，却也从未想过。</p>
<p>毛主席伟岸的身躯依旧耀眼的矗立着，游客换了一波又一波。人生如匆匆过客，无论是在她人的生活还是自己的生活中。</p>
<p>转眼间新学期又开始了，宿舍和实验室完成了这篇看似惆怅却满是牢骚的日志。新的学期新的开始！有一句话说的好不要在怀念过去回忆过去中浪费掉你现在的生活！收拾行装，未来就在脚下！</p>
<img src="/2021/03/21/memory/memory.jpg" class="">

<p>辛丑牛年农历二月初十</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown</title>
    <url>/2021/04/15/markdown/</url>
    <content><![CDATA[<p><strong>Markdown</strong>是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。</p>
<p>格式如下图：</p>
<img src="/2021/04/15/markdown/md.jpg" class="">]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>mpc</title>
    <url>/2021/08/26/mpc/</url>
    <content><![CDATA[<h1 id="SmartBid"><a href="#SmartBid" class="headerlink" title="SmartBid"></a>SmartBid</h1><h2 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h2><h3 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h3><p>Work with Hyperledger Fabric v. 1.1.1-mpc (WARNING you need to install 1.1.1-mpc as described below)</p>
<p>Follow <a href="https://hyperledger-fabric.readthedocs.io/en/latest/prereqs.html">https://hyperledger-fabric.readthedocs.io/en/latest/prereqs.html</a> and <a href="https://github.com/hyperledger/fabric-sdk-node">https://github.com/hyperledger/fabric-sdk-node</a>. In particular:</p>
<ul>
<li><p><code>go</code> <a href="https://golang.org/">https://golang.org/</a> - most recent version. On Ubuntu DO NOT INSTALL USING <code>apt-get</code>. It will NOT work (outdated version). You may use the <code>snap</code> version but you might have the following issue: <a href="https://github.com/golang/go/issues/24674#issuecomment-379919460">https://github.com/golang/go/issues/24674#issuecomment-379919460</a>. Instead, it is better to manually install it in your home directory:</p>
<pre><code>  mkdir ~/opt
  cd ~/opt
  wget https://dl.google.com/go/go1.10.3.linux-amd64.tar.gz
  tar xvzf go1.10.3.linux-amd64.tar.gz</code></pre>
<p>  and add the following lines to <code>~/.zshrc</code> or <code>~/.bashrc</code></p>
<pre><code>  export GOROOT=$HOME/opt/go
  export PATH=$PATH:$GOROOT/bin</code></pre>
</li>
</ul>
<ul>
<li><code>docker</code> <a href="https://www.docker.com/products/overview">https://www.docker.com/products/overview</a>- v1.13 or higher</li>
<li><code>docker compose</code> <a href="https://docs.docker.com/compose/overview/">https://docs.docker.com/compose/overview/</a> - v1.8 or higher (<code>sudo pip install docker-compose</code>)</li>
<li><code>node.js</code>, <code>npm</code> <a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a><ul>
<li>node runtime version and 8.4.0 or higher (NodeJS &gt; 8 is not supported by <code>fabric-node-sdk</code>, and we need NodeJS &gt;= 8 for async/await)</li>
<li>npm v3.10.10</li>
</ul>
</li>
<li>on MacOS: need <code>gnu-tar</code> and <code>coreutils</code>: with Homebrew: <code>brew install gnu-tar --with-default-names</code>, <code>brew install coreutils</code> (needs to change path)</li>
</ul>
<p>In addition:</p>
<ul>
<li><code>gulp</code> - install via <code>npm install -g gulp</code></li>
<li><code>yarn</code> - install via <code>npm install -g yarn</code> / <code>brew install yarn</code> / … -&gt; npm might be used but it seems to be too unreliable</li>
<li><code>tmux</code> &amp; <code>tmuxinator</code> - if you want to use them</li>
</ul>
<p><em>Warning</em>: Not using the indicated versions might lead to errors very hard to debug.</p>
<p>The <code>$GOPATH</code> must be set.</p>
<p>For <code>carbuy-go</code>: (this dependencies are OPTIONAL but highly recommended; they are required to locally compile the chaincode, outside the Docker container <code>fabric-ccenv-mpc</code>)</p>
<ul>
<li><p><code>swig</code> - We need a recent version of <code>swig</code>. The default version of swig in Ubuntu 16.04 has a bug: <a href="https://github.com/swig/swig/issues/619">https://github.com/swig/swig/issues/619</a>. Tested with 3.0.12. For Ubuntu, inside <code>swig</code> source folder (downloaded from <a href="http://www.swig.org/download.html">http://www.swig.org/download.html</a>):</p>
<pre><code>  sudo apt-get install libpcre3 libpcre3-dev
  ./configure
  make
  sudo make install</code></pre>
</li>
<li><p><code>emp-tookit</code> from the <code>carbuy</code> branch from <code>https://github.com/fabrice102/</code></p>
<ul>
<li><p>on Ubuntu:<br>go the the folder you want to install it:</p>
<pre><code>wget https://raw.githubusercontent.com/fabrice102/emp-readme/carbuy/scripts/setup_new_machine.sh -O emp_install.sh &amp;&amp; bash emp_install.sh</code></pre>
<p>and then follows instruction “on both” below</p>
</li>
<li><p>on macOS:<br>go the the folder you want to install it:</p>
<ul>
<li><p><code>git clone -b carbuy https://github.com/fabrice102/emp-readme.git</code></p>
</li>
<li><p>install pre-requisites using HomeBrew</p>
</li>
<li><p>add <code>export OPENSSL_ROOT_DIR=/usr/local/opt/openssl</code> to an init script (e.g., <code>~/.zshrc</code> if <code>zsh</code> is used) and run it</p>
</li>
<li><p>run</p>
<pre><code>  bash emp-readme/scripts/install_emp-tool.sh
  bash emp-readme/scripts/install_emp-ot.sh
  bash emp-readme/scripts/install_emp-m2pc.sh
  bash emp-readme/scripts/install_emp-sh2pc.sh</code></pre>
</li>
<li><p><em>warning</em>: the flag <code>-DUSE_RANDOM_DEVICE=yes</code> for <code>cmake</code> is required to not use <code>rdrand</code> on systems not supporting <code>rdrand</code></p>
</li>
<li><p>you can run <code>cmake</code> manually with the flags:</p>
<pre><code>  -DCMAKE_INSTALL_PREFIX=$HOME/usr  # for a local install
  -DCMAKE_BUILD_TYPE=DEBUG # for a debug version</code></pre>
<p>in the latter case, as we cannot use <code>cmake</code> within <code>carbuy-go</code>, you need to set up correctly <code>LD_LIBRARY_PATH</code> before doing anything on <code>carbuy-go</code>.<br>To avoid breaking <code>rpath</code> mechanisms, it is not recommended to change <code>LD_LIBRARY_PATH</code>, <code>LIBRARY_PATH</code>, or <code>DYLD_LIBRARY_PATH</code> for all the system.</p>
</li>
</ul>
</li>
<li><p>on both, add to <code>~/.zshrc</code>, <code>~/.bashrc</code>, or a similar file:</p>
<pre><code>export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/local/include/emp-tool:/usr/local/include/emp-sh2pc:/usr/local/include/emp-ot</code></pre>
</li>
</ul>
</li>
<li><p><code>dep</code> <a href="https://github.com/golang/dep">https://github.com/golang/dep</a></p>
</li>
</ul>
<p>We assume that:</p>
<ul>
<li>The environment variable <code>$CARBUYDIR</code> points to an existing directory (e.g., <code>~/projects/carbuy</code>)</li>
<li>This repository <code>carbuy-client</code> is cloned in <code>$CARBUYDIR/carbuy-client</code>.</li>
<li>The repository <code>carbuy-go</code> is cloned in <code>$GOPATH/src/carbuy</code>.</li>
</ul>
<p>In other words:</p>
<pre><code>cd $CARBUYDIR
git clone [url carbuy-client] carbuy-client

cd $GOPATH/src
git clone [url carbuy-go] carbuy</code></pre>
<h3 id="Compilation-installation-of-dependencies"><a href="#Compilation-installation-of-dependencies" class="headerlink" title="Compilation / installation of dependencies"></a>Compilation / installation of dependencies</h3><p><em>Important</em>: These steps might need to be done again after an update.</p>
<h4 id="Fabric-v1-1-1-mpc"><a href="#Fabric-v1-1-1-mpc" class="headerlink" title="Fabric v1.1.1-mpc"></a>Fabric v1.1.1-mpc</h4><pre><code>mkdir -p $GOPATH/src/github.com/hyperledger
cd $GOPATH/src/github.com/hyperledger
git clone -b mpc_e2e https://github.com/fabrice102/fabric   # only the first time - if the folder &quot;fabric&quot; does not already exists, else check you are on the remote and mpc_e2e branch (cd fabric; git status)
cd fabric
git pull
make docker</code></pre>
<h4 id="carbuy-client"><a href="#carbuy-client" class="headerlink" title="carbuy-client"></a>carbuy-client</h4><pre><code>cd $CARBUYDIR/carbuy-client
git submodule update --init
cd fabric-sdk-node
yarn
gulp ca
cd ..
yarn

cd $CARBUYDIR/carbuy-client/fabric
./bootstrap.sh

cd $CARBUYDIR/carbuy-client/fabric/fabric-ccenv-carbuy
docker build --no-cache -t fabric-ccenv-carbuy:x86_64-1.1.1-mpc .</code></pre>
<h4 id="carbuy-go"><a href="#carbuy-go" class="headerlink" title="carbuy-go"></a>carbuy-go</h4><p>This step is only required if you want to locally compile the chaincode.</p>
<pre><code>cd $GOPATH/src/carbuy
dep ensure</code></pre>
<h3 id="1-Running-the-fabric"><a href="#1-Running-the-fabric" class="headerlink" title="1. Running the fabric"></a>1. Running the fabric</h3><p>Run</p>
<pre><code>cd &quot;$CARBUYDIR/carbuy-client/fabric/network&quot;
./byfn.sh -m generate
./byfn.sh -m up</code></pre>
<p>At the end, you should see</p>
<pre><code>===================== Anchor peers for org &quot;Org1MSP&quot; on &quot;mychannel&quot; is updated successfully =====================

========= All GOOD, BYFN execution completed ===========


 _____   _   _   ____
| ____| | \ | | |  _ \
|  _|   |  \| | | | | |
| |___  | |\  | | |_| |
|_____| |_| \_| |____/</code></pre>
<p>To stop the fabric:</p>
<pre><code>cd &quot;$CARBUYDIR/carbuy-client/fabric/network&quot;
./byfn.sh -m down</code></pre>
<p>In this case, the ledger is destroyed.</p>
<h3 id="2-Deploying-the-carbuy-application"><a href="#2-Deploying-the-carbuy-application" class="headerlink" title="2. Deploying the carbuy application"></a>2. Deploying the carbuy application</h3><p>Now you need to deploy the chaincode:</p>
<pre><code>cd $CARBUYDIR/carbuy-client
node deploy</code></pre>
<p>Each deploy generates a fresh <code>chaincodeID</code> which is stored in <code>chaincodeID.txt</code>.<br>Therefore only the last deployed chaincode is actually used (except if you change <code>chaincodeID.txt</code>).<br>Furthermore, each deployment starts from a fresh empty ledger that way.</p>
<p><em>Note</em>: <code>node deploy</code> is equivalent to <code>node deploy.js</code>.</p>
<h3 id="3-Populate-the-database"><a href="#3-Populate-the-database" class="headerlink" title="3. Populate the database"></a>3. Populate the database</h3><p>You can create initial entries into the database by using the <code>populate.sh</code> script:</p>
<pre><code>cd $CARBUYDIR/carbuy-client
./scripts/populate.sh</code></pre>
<p>Other smaller populate scripts are available (look for <code>populate*.sh</code>).</p>
<h3 id="4-Accessing-the-smartbid-application-using-command-line-OPTIONAL"><a href="#4-Accessing-the-smartbid-application-using-command-line-OPTIONAL" class="headerlink" title="4. Accessing the smartbid application using command line (OPTIONAL)"></a>4. Accessing the smartbid application using command line (OPTIONAL)</h3><p>Now, you can run the <code>invoke</code> (or <code>query</code> if you don’t need the transaction to be recorded) command with different parameters. The command gets the name of the function that is executed (e.g. createItem, etc.) and a structure that includes all of the variables for the command.</p>
<p>For example:</p>
<pre><code>cd $CARBUYDIR/carbuy-client

node invoke org0 createItem &#39;&#123;
    &quot;id&quot;:              &quot;715987522&quot;,
    &quot;sellerID&quot;:        &quot;org0&quot;,
    &quot;name&quot;:            &quot;House, White Plains&quot;,
    &quot;category&quot;:        &quot;Real Estate&quot;,
    &quot;description&quot;:     &quot;&quot;,
    &quot;auctionDateTime&quot;: 1494648000,
    &quot;startPrice&quot;:      10000,
    &quot;reservePrice&quot;:    &#39;$(node encrypt org0 30000)&#39;,
    &quot;soldPrice&quot;:       0,
    &quot;owner&quot;:           &quot;&quot;,
    &quot;status&quot;:          &quot;available&quot;
&#125;&#39;

node invoke org2 makeBid &#39;&#123;
    &quot;sellerID&quot;:        &quot;org0&quot;,
    &quot;itemID&quot;:          &quot;715987522&quot;,
    &quot;buyerID&quot;:         &quot;org2&quot;,
    &quot;price&quot;:           &#39;$(node encrypt org2 15000)&#39;,
    &quot;bidDateTime&quot;:     1493152448,
    &quot;valid&quot;:           true
&#125;&#39;

node invoke org1 createItem &#39;&#123;
    &quot;id&quot;:              &quot;715987524&quot;,
    &quot;sellerID&quot;:        &quot;org1&quot;,
    &quot;name&quot;:            &quot;House, Yorktown&quot;,
    &quot;category&quot;:        &quot;Real Estate&quot;,
    &quot;description&quot;:     &quot;&quot;,
    &quot;auctionDateTime&quot;: 1494648000,
    &quot;startPrice&quot;:      10000,
    &quot;reservePrice&quot;:    &#39;$(node encrypt org1 25000)&#39;,
    &quot;soldPrice&quot;:       0,
    &quot;owner&quot;:           &quot;&quot;,
    &quot;status&quot;:          &quot;available&quot;
&#125;&#39;

node query org2 getMyItemsWithBids org2</code></pre>
<p>The first argument is a comma-separated list of orgs to be contacted. The following arguments correspond to the invoke function of the chaincode and its arguments.</p>
<p>The reserve price is confidential. Therefore, an encryption of the price is saved on the chaincode and not the plaintextValue.</p>
<p><code>node encrypt</code> enables to encrypt data for a given organization.</p>
<h3 id="5-Running-the-web-server-OPTIONAL"><a href="#5-Running-the-web-server-OPTIONAL" class="headerlink" title="5. Running the web server (OPTIONAL)"></a>5. Running the web server (OPTIONAL)</h3><p>The web server provides a nicer interface than the command line.<br>To run it:</p>
<pre><code>cd $CARBUYDIR/carbuy-client
node app</code></pre>
<p>When developing for the web server, it is convenient to restart it whenever needed.<br>For that, you can use <code>nodemon</code>. To install it:</p>
<pre><code>cd $CARBUYDIR/carbuy-client
npm install -g nodemon</code></pre>
<p>To run the web server using <code>nodemon</code>:</p>
<pre><code>nodemon -e &#39;*&#39; app.js</code></pre>
<h3 id="Running-everything-above-automatically"><a href="#Running-everything-above-automatically" class="headerlink" title="Running everything above automatically"></a>Running everything above automatically</h3><p>Just run</p>
<pre><code>$CARBUYDIR/carbuy-client/scripts/start.sh</code></pre>
<p><em>TIP</em>: You can add the option <code>--populate</code> to <code>$CARBUYDIR/carbuy-client/scripts/start.sh</code>  to automatically populate after deploy.</p>
<p><em>TIP</em>: If you are in a hurry and want only a small set of data, you can just use <code>$CARBUYDIR/carbuy-client/scripts/populateQuick.sh</code> or <code>$CARBUYDIR/carbuy-client/scripts/populateMin.sh</code>.</p>
<p><em>TIP</em>: You can add the option <code>--no-app</code> to <code>$CARBUYDIR/carbuy-client/scripts/start.sh</code> to not launch the server. You can then run <code>$CARBUYDIR/carbuy-client/scripts/simpleTest.sh</code> to run a simple test auction.</p>
<h3 id="6-Stopping-everything"><a href="#6-Stopping-everything" class="headerlink" title="6. Stopping everything"></a>6. Stopping everything</h3><pre><code>$CARBUYDIR/carbuy-client/scripts/stop.sh</code></pre>
<h3 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h3><p>If you want to update all repos and compile what needs to be compiled, you can use</p>
<pre><code>$CARBUYDIR/carbuy-client/scripts/update.sh</code></pre>
<h2 id="Organization"><a href="#Organization" class="headerlink" title="Organization"></a>Organization</h2><ul>
<li><code>fabric/</code>: files used to run the fabric orderer, peers, …</li>
<li><code>static/</code>: static files of the web server</li>
<li><code>data/</code>: fake database for the web server, used to store e.g., picture of users and cars: picture of with <code>id</code> from org0 <code>org0ID</code> is stored in <code>data/&lt;org0ID&gt;/&lt;id&gt;.png</code></li>
<li><code>lib/</code>: templates, plugins, and other tools for the web server and <code>deploy.js</code>, …</li>
<li><code>scripts/</code>: various scripts to make life easier</li>
<li><code>test/</code>: mocha test files (to be run with <code>npm test</code>)</li>
<li><code>config.json</code>: configuration file for everything</li>
<li><code>manifest.js</code>: configuration file for the web server</li>
<li><code>deploy.js</code>, <code>invoke.js</code>, <code>query.js</code>: see above</li>
<li><code>chaincodeID.txt</code>: file created by <code>deploy.js</code> containing the chaincode ID of the last deployed chaincode</li>
</ul>
<h2 id="Unit-testing"><a href="#Unit-testing" class="headerlink" title="Unit testing"></a>Unit testing</h2><p>For the JS part, we are using <code>mocha</code>.<br>To run the tests:</p>
<pre><code>cd $CARBUYDIR/carbuy-client
npm test</code></pre>
<h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><h3 id="Peers"><a href="#Peers" class="headerlink" title="Peers"></a>Peers</h3><p>WARNING: This section is completely out of date.</p>
<p>Following the tutorial above, you get three peers: <code>org0</code>, <code>org1</code>, and <code>org2</code>.<br>However, the chaincode is oblivious to this and can work with any number of peers for most function calls, except when holding an auction which can only be done between three peers.</p>
<p>When the chaincode is deployed, the <code>init</code> function should be given the list of peer IDs.<br>This is automatically done by <code>deploy.js</code>.</p>
<p><em>Warning</em>: Peer name should only contains alphanumerical characters, <code>-</code> and <code>_</code>.</p>
<h3 id="Data-model-structures-stored-on-the-blockchain"><a href="#Data-model-structures-stored-on-the-blockchain" class="headerlink" title="Data model / structures stored on the blockchain"></a>Data model / structures stored on the blockchain</h3><p>The data model is defined explicitly in the chaincode (<code>carbuy-go</code>), and must be kept in synch manually.<br>More precisely, the structures are defined at the top of <code>seller.go</code>, <code>buyer.go</code>, and <code>encrypted.go</code>, in the folder <code>$GOPATH/src/carbuy/chaincode/</code>.</p>
<p>Comments indicate under which key the structures are stored on the blockchain.</p>
<h3 id="Invoke-queries"><a href="#Invoke-queries" class="headerlink" title="Invoke queries"></a>Invoke queries</h3><p>There are five functions which can be invoked: <code>createItem</code>, <code>getMyItemsWithBids</code>, <code>getOtherItemsWithBids</code>, <code>makeBid</code>, <code>holdAuction</code>. Each of these functions gets <code>(stub, args)</code>, where <code>args</code> includes all of the input parameters.</p>
<p>The invoke queries are called in <code>$GOPATH/src/carbuy/chaincode/main.go</code>, function <code>Invoke</code>.</p>
<h2 id="Workarounds-and-dirty-details"><a href="#Workarounds-and-dirty-details" class="headerlink" title="Workarounds and dirty details"></a>Workarounds and dirty details</h2><h3 id="carbuy-client-1"><a href="#carbuy-client-1" class="headerlink" title="carbuy-client"></a>carbuy-client</h3><h4 id="Npm-packages"><a href="#Npm-packages" class="headerlink" title="Npm packages"></a>Npm packages</h4><p>We use the following workarounds in <code>package.json</code>:</p>
<ul>
<li>The npm package <code>node-hashtable</code> does not compile on macos Sierra. We instead use <a href="https://github.com/fabrice102/node-hashtable">https://github.com/fabrice102/node-hashtable</a>.</li>
<li>The npm package <code>grpc</code> seems to be manually installed at least on macos Sierra.</li>
<li>The npm package <code>winston</code> seems to be a dependency of fabric-client which has to be manually installed <code>node_modules/fabric-client/lib/utils.js:25:15</code>.</li>
</ul>
<h4 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h4><p>We only look at the events from the <code>org0</code> peer. This should never be an issue at least in our setting.</p>
<h3 id="carbuy-go-1"><a href="#carbuy-go-1" class="headerlink" title="carbuy-go"></a>carbuy-go</h3><h4 id="Vendor-and-package-versions"><a href="#Vendor-and-package-versions" class="headerlink" title="Vendor and package versions"></a>Vendor and package versions</h4><p>We use <code>golang dep</code> to simplify dependencies management.</p>
<p>However, for speed, we do not vendor anything in the chaincode. Instead <code>fabric-ccenv-carbuy</code> contains already everything that is requires.<br>Thus, no need for compilation each time and installation is faster.</p>
<h4 id="SWIG"><a href="#SWIG" class="headerlink" title="SWIG"></a>SWIG</h4><p>We need <code>swig</code>. For that we need two changes:</p>
<ul>
<li>Patch <code>node_modules/fabric-client/lib/packager/Golang.js</code> to support <code>swig</code>; concretely, we use <code>fabric-sdk-node</code> as a submodule, from branch <code>swig-support</code> from <a href="https://github.com/fabrice102/fabric-sdk-node.git">https://github.com/fabrice102/fabric-sdk-node.git</a>.</li>
<li>Use of <code>CORE_CHAINCODE_BUILDER</code> and <code>$CARBUYDIR/carbuy-client/fabric/fabric-ccenv-carbuy</code>, cf above. We need a recent version of <code>swig</code>, because the default version of swig in Ubuntu 16.04 has a bug: <a href="https://github.com/swig/swig/issues/619">https://github.com/swig/swig/issues/619</a>.</li>
</ul>
<h2 id="Other-remarks"><a href="#Other-remarks" class="headerlink" title="Other remarks"></a>Other remarks</h2><p>We use <a href="https://github.com/hyperledger/fabric/blob/master/docs/source/asset_setup.rst">https://github.com/hyperledger/fabric/blob/master/docs/source/asset_setup.rst</a> as a base, with various changes.<br>In particular <code>peer0</code>, <code>peer1</code>, and <code>peer2</code> have been renamed <code>org0</code>, <code>org1</code>, and <code>org2</code>.<br>Furthermore the network id has been changed from <code>peer0</code> to <code>carbuy</code>.</p>
<p>The web server uses <code>hapijs</code> <a href="https://hapijs.com/">https://hapijs.com/</a>.<br>The pages use <code>bootstrap</code> <a href="https://getbootstrap.com/">https://getbootstrap.com/</a>.</p>
<p><em>IMPORTANT</em>: Keys must be changed on production. They are stored both in <code>$CARBUYDIR/carbuy-client/keys/</code> and in <code>$GOPATH/src/carbuy/helper/server/config/config.go</code>.</p>
<h2 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><h3 id="Error-GRPC-client-got-an-error-response-from-the-peer-Error-Error-executing-chaincode-Failed-to-execute-transaction-when-invoking"><a href="#Error-GRPC-client-got-an-error-response-from-the-peer-Error-Error-executing-chaincode-Failed-to-execute-transaction-when-invoking" class="headerlink" title="Error GRPC client got an error response from the peer. Error: Error executing chaincode: Failed to execute transaction when invoking"></a>Error <code>GRPC client got an error response from the peer. Error: Error executing chaincode: Failed to execute transaction</code> when invoking</h3><p>To debug this error, look at the logs of the chaincode</p>
<pre><code>docker logs carbuy-[peer]-[chaincodeid]-....</code></pre>
<p>Use autocompletion to make your life easier.</p>
<h3 id="Issues-with-npm-or-weird-JS-issues"><a href="#Issues-with-npm-or-weird-JS-issues" class="headerlink" title="Issues with npm or weird JS issues"></a>Issues with <code>npm</code> or weird JS issues</h3><p>Use <code>yarn</code> as <code>npm</code> often creates weird issues.</p>
<p>If you insist on using <code>npm</code>, here are some comments.</p>
<p>Might be useful to remove <code>node_modules</code> and <code>package-lock.json</code> and run <code>npm install</code> again.<br>True also inside <code>fabric-sdk-node</code>. (See requirements at the beginning.)</p>
<p>If problems with versions, might be useful to remove <code>package-lock.json</code> too.</p>
<p>See <a href="https://github.com/npm/npm/issues/16839">https://github.com/npm/npm/issues/16839</a></p>
<h3 id="Issues-with-installation-of-chaincode"><a href="#Issues-with-installation-of-chaincode" class="headerlink" title="Issues with installation of chaincode"></a>Issues with installation of chaincode</h3><p>Check that you gave the latest <code>fabric-ccenv-carbuy</code> Docker image.<br>Otherwise run:</p>
<pre><code>cd $CARBUYDIR/carbuy-client/fabric/fabric-ccenv-carbuy
docker build --no-cache -t fabric-ccenv-carbuy:x86_64-1.1.0-alpha-mpc .</code></pre>
<h3 id="Other-random-errors"><a href="#Other-random-errors" class="headerlink" title="Other random errors"></a>Other random errors</h3><p>In some cases just rebooting the machine solves some errors.</p>
<h3 id="Chaincode-dead-lock"><a href="#Chaincode-dead-lock" class="headerlink" title="Chaincode dead lock"></a>Chaincode dead lock</h3><p>To debug send signal QUIT to process 1 in the docker container of the chaincode and look at the logs.<br><a href="https://stackoverflow.com/a/28699595/2945326">https://stackoverflow.com/a/28699595/2945326</a></p>
<h3 id="Errors-on-the-chaincode"><a href="#Errors-on-the-chaincode" class="headerlink" title="Errors on the chaincode"></a>Errors on the chaincode</h3><p>Debugging can be eased by changing PRINT_LINE define on top of <code>$GOPATH/src/carbuy/chaincode/mpc/mpc.cpp</code>.</p>
<h3 id="Acknowledgement"><a href="#Acknowledgement" class="headerlink" title="Acknowledgement"></a>Acknowledgement</h3><p>Thanks to Research fellow, Shai Halevi for his guidance and help.</p>
]]></content>
      <tags>
        <tag>安全多方计算</tag>
      </tags>
  </entry>
  <entry>
    <title>rain</title>
    <url>/2021/03/26/rain/</url>
    <content><![CDATA[<p>今日，北京的天空雾霾霾的，温度也不如前几日舒服。不到中午，天空便下起了小雨。原定于今天打篮球的计划也泡汤了。只得呆在实验室学习，这或许是老天想让我好好学习，天天向上吧！</p>
<p>下午，一位考研的学妹联系我说调剂了中国石油大学，准备复试。听到这个消息为她高兴。作为一名考研的过来人，我深知考研的艰辛，特别是考好大学的艰辛。在这个日益内卷化，本科学历也越来越贬值的社会，读研也成为了一种标配。希望考验人都能成功上岸吧！</p>
<p>辛丑年农历二月十四</p>
<p>周六的北京似乎变得比平常安静了，在连续上班近一周后，大家也迎来了休息的机会。可我却怎么也休息不起来，心中的石头还没放下。昨天晚上做了一个奇怪的梦，怪到记忆犹新却不愿发生，怪到那么不真实。看来，日有所思夜有所梦这句话还是有一定道理的。不过没有什么能阻挡我学习的脚步，生活继续，梦在脚下。坚持才会有量变到质变。加油，读书人！</p>
<p>辛丑年农历二月十五</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>如晴似雨</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro</title>
    <url>/2020/10/08/shiro-base/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Apache shiro是一个强大的且容易使用的Java安全框架，执行身份验证（认证）、授权、加密和会话管理。<br>Shiro有三个核心概念，<strong>Subject，SecurityManager，Realms</strong>。<br><strong>shiro顶层图</strong></p>
<img src="/2020/10/08/shiro-base/shiro-high.png" class="">

<p><strong>shiro详细架构图</strong></p>
<img src="/2020/10/08/shiro-base/shiro-detail.png" class="">

<h4 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h4><p>Subject意味着<strong>当前正在执行的用户</strong>，但它不仅仅指代User，还可以是<strong>第三方进程</strong>，<strong>后台账户</strong>或其它类似的任何东西。It simply means ‘the thing that is currently interacting with the software’.</p>
<h4 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h4><p>SecurityManager管理所有用户的安全操作，是shiro的核心。</p>
<h4 id="Realms"><a href="#Realms" class="headerlink" title="Realms"></a>Realms</h4><p>Realm在Shiro和你的应用安全数据之间充当桥或者连接器的角色。</p>
<h4 id="其它重要概念"><a href="#其它重要概念" class="headerlink" title="其它重要概念"></a>其它重要概念</h4><p><strong>Authentication（认证）</strong><br>认证就是一个验证用户身份的过程，也叫登录。<br><strong>Authorization（授权）</strong><br>授权就是对一个已经登陆的用户授予其访问系统资源的权限。<br><strong>Session Management（会话管理）</strong><br>类似于web中session，这个session是apache shiro特有的。<br><strong>Cryptography（密码学）</strong><br>密码学就是一个混淆或隐藏数据的过程。</p>
<h3 id="单机版应用"><a href="#单机版应用" class="headerlink" title="单机版应用"></a>单机版应用</h3><h4 id="ini文件"><a href="#ini文件" class="headerlink" title="ini文件"></a>ini文件</h4><p>可以将一些subject对象的数据写到shiro.ini文件中，例如用户名、密码之类的信息。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>1.创建安全管理器对象</strong><br><code>DefaultSecurityManager securityManager = new DefaultSecurityManager();</code></p>
<p><strong>2.给安全管理器设置realm</strong><br><code>securityManager.setRealm(new IniRealm(&quot;classpath:shiro.ini&quot;));</code></p>
<p><strong>3.SecurityUtils给全局安全工具类设置安全管理器</strong><br><code>SecurityUtils.setSecurityManager(securityManager);</code></p>
<p><strong>4.关键对象subject（主体）</strong><br><code>Subject subject = SecurityUtils.getSubject();</code></p>
<p><strong>5.创建令牌</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UsernamePasswordToken token &#x3D; new UsernamePasswordToken(&quot;hejun&quot;,&quot;123456&quot;);</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">    subject.login(token);  &#x2F;&#x2F;用户认证</span><br><span class="line">    System.out.println(&quot;认证状态: &quot; + subject.isAuthenticated());</span><br><span class="line">&#125; catch(Exception e) &#123;</span><br><span class="line">    e.printSstackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义realm"><a href="#自定义realm" class="headerlink" title="自定义realm"></a>自定义realm</h3><p>自定义realm的作用就是将认证/授权的数据来源转为数据库，丢掉shiro.ini文件。</p>
<img src="/2020/10/08/shiro-base/extends-diagram.png" class="">
<p><strong>1.继承AuthorizingRealm类，重写两个方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 自定义realm  将认证&#x2F;授权数据的来源转为数据库</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CustomRealm extends AuthorizingRealm &#123;</span><br><span class="line">    &#x2F;&#x2F;授权</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;认证</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;</span><br><span class="line">        &#x2F;&#x2F;token中获取用户名</span><br><span class="line">        String principal &#x3D; (String) authenticationToken.getPrincipal();</span><br><span class="line">        System.out.println(principal);</span><br><span class="line">        &#x2F;&#x2F;根据身份信息使用jdbc mybatis查询相关数据库</span><br><span class="line">        if (&quot;hj&quot;.equals(principal)) &#123;</span><br><span class="line">            &#x2F;&#x2F;参数1，2：返回数据库中的正确用户名和密码</span><br><span class="line">            return new SimpleAuthenticationInfo(principal, &quot;123&quot;, this.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.测试</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestCustomRealmAuthenticator &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建securityManager</span><br><span class="line">        DefaultSecurityManager defaultSecurityManager &#x3D; new DefaultSecurityManager();</span><br><span class="line">        &#x2F;&#x2F;设置自定义realm</span><br><span class="line">        defaultSecurityManager.setRealm(new CustomRealm());</span><br><span class="line">        &#x2F;&#x2F;为全局安全工具类设置securityManager</span><br><span class="line">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class="line">        &#x2F;&#x2F;通过全局安全工具类获得subject</span><br><span class="line">        Subject subject &#x3D; SecurityUtils.getSubject();</span><br><span class="line">        &#x2F;&#x2F;创建token</span><br><span class="line">        UsernamePasswordToken token &#x3D; new UsernamePasswordToken(&quot;hj&quot;, &quot;123&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">            System.out.println(&quot;login success&quot;);</span><br><span class="line">        &#125; catch (AuthenticationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>最终在SimpleAccountRealm这个类中的doGetAuthenticationInfo方法中完成用户名的校验。</strong></p>
<p><strong>密码校验在AuthenticatingRealm的assertCredentialsMatch完成。密码校验是自动完成的。</strong></p>
<p><strong>AuthenticatingRealm 认证realm doGetAuthenticationInfo</strong></p>
<p><strong>AuthorizingRealm 授权realm doGetAuthorizationInfo</strong></p>
]]></content>
      <categories>
        <category>技术栈</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>umlarrow</title>
    <url>/2021/03/31/umlarrow/</url>
    <content><![CDATA[<h3 id="泛化（继承）"><a href="#泛化（继承）" class="headerlink" title="泛化（继承）"></a>泛化（继承）</h3><p>泛化是一种一般与特殊、一般与具体关系的描述，具体建立在一般之上并对其进行扩展。<br><strong>实线空心三角箭头表示</strong></p>
<img src="/2021/03/31/umlarrow/generate.png" class="">

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现是类与接口之间关系的描述，类是接口所有特征和行为的具体实现。<br><strong>虚线空心三角箭头表示</strong></p>
<img src="/2021/03/31/umlarrow/implement.png" class="">

<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>依赖是一种使用关系，即一个类的实现需要另一个类的帮助。通常一个类的方法参数中需要传入另一个类的对象，即表示依赖这个类。<br><strong>虚线箭头</strong></p>
<img src="/2021/03/31/umlarrow/rely.png" class="">

<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>关联表示类与类之间的联接，一个类知道另一个类的方法和属性，这种关系比依赖更强。一般一个类作为另一个类的全局变量，即表示关联这个类。<br><strong>实线箭头</strong></p>
<img src="/2021/03/31/umlarrow/relevance.png" class="">


<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>聚合是关联的一种特例，是更强的关联。聚合是整体和个体之间的关系，即<strong>has-a</strong>的关系。关联关系中两个类是处于相同的层次,而聚合关系中两个类是处于不同的层次，一个表示整体, 一个表示个体。</p>
<img src="/2021/03/31/umlarrow/juhe.png" class="">

<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>组合也是关联的一种特例。组合是整体与部分的关系，即<strong>contains-a</strong>的关系，比聚合更强。</p>
<img src="/2021/03/31/umlarrow/union.png" class="">

]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>箭头含义</tag>
      </tags>
  </entry>
</search>
